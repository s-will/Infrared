<!-- HTML header for doxygen 1.9.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="$langISO">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Infrared: Network parsimony</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<!-- $darkmode -->
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="style.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
  DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
  DoxygenAwesomeInteractiveToc.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
  DoxygenAwesomeParagraphLink.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
  DoxygenAwesomeFragmentCopyButton.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Infrared
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_Doc_Examples_NetworkParsimony.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Network parsimony </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md97">Online resources and software environment</a></li>
<li class="level1"><a href="#autotoc_md99">The problem(s) of network parsimony</a></li>
<li class="level1"><a href="#autotoc_md100">Hardwired parsimony</a></li>
<li class="level1"><a href="#autotoc_md101">Softwired parsimony</a></li>
<li class="level1"><a href="#autotoc_md102">Parental parsimony</a></li>
<li class="level1"><a href="#autotoc_md103">An example input instance</a></li>
<li class="level1"><a href="#autotoc_md104">Model hardwired parsimony</a><ul><li class="level2"><a href="#autotoc_md105">Define a hamming distance function between nodes</a></li>
<li class="level2"><a href="#autotoc_md106">Construct the model</a></li>
<li class="level2"><a href="#autotoc_md107">Run optimization</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md108">Model softwired parsimony with additional state (effectively keeps tree width!)</a><ul><li class="level2"><a href="#autotoc_md109">Define hamming distance for reticualtions</a></li>
<li class="level2"><a href="#autotoc_md110">Construct model</a></li>
<li class="level2"><a href="#autotoc_md111">Run optimization</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md112">Model softwired parsimony with ternary constraint</a><ul><li class="level2"><a href="#autotoc_md113">Define hamming distance for reticualtions</a></li>
<li class="level2"><a href="#autotoc_md114">Construct model</a></li>
<li class="level2"><a href="#autotoc_md115">Run optimization</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md116">Model parental parsimony</a><ul><li class="level2"><a href="#autotoc_md117">Model character sets as integer values</a></li>
<li class="level2"><a href="#autotoc_md118">Define distances on set labels</a></li>
<li class="level2"><a href="#autotoc_md119">Define constraint types</a></li>
<li class="level2"><a href="#autotoc_md120">Construct model</a></li>
<li class="level2"><a href="#autotoc_md121">Run optimization</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md122">APPENDIX</a></li>
<li class="level1"><a href="#autotoc_md123">Grid networks</a></li>
</ul>
</div>
<div class="textblock"><hr  />
<h1><a class="anchor" id="autotoc_md97"></a>
Online resources and software environment</h1>
<p >​</p>
<p >This document is hosted online as <a href="https://www.lix.polytechnique.fr/~will/Software/Infrared/current/Doc/NetworkParsimony.ipynb">Jupyter notebook</a> with precomputed results. Download this file to view, edit and run examples in Jupyter.</p>
<p >​</p>
<p >We recommend to install all required software using Mamba (or Conda) and PIP.</p>
<div class="fragment"><div class="line">mamba create -n infrared -c conda-forge infrared jupyter jupytext matplotlib seaborn graphviz</div>
<div class="line"> </div>
<div class="line">mamba activate infrared</div>
<div class="line"> </div>
<div class="line">pip install graphviz</div>
<div class="line"> </div>
<div class="line">mamba deactivate infrared</div>
</div><!-- fragment --><p >​</p>
<p >Start the Jupyter notebook server after activating the environment</p>
<div class="fragment"><div class="line">mamba activate infrared</div>
<div class="line"> </div>
<div class="line">jupyter notebook</div>
</div><!-- fragment --><p >The <a href="https://gitlab.inria.fr/amibio/Infrared/-/tree/master/Doc/Examples">original sources</a> are part of the Infrared distribution and hosted on Gitlab (in Jupytext light Script format).</p>
<p >​</p>
<hr  />
<h1><a class="anchor" id="autotoc_md99"></a>
The problem(s) of network parsimony</h1>
<p >The small parsimony problem is typically defined over phylogenetic trees. First assuming that traits are inherited independently of each other, we consider the problem for a single trait with possible characters in set \(C\). The input of the small tree parsimony problem is a tree and a labeling of the leaves by characters in \(C\). The problem asks for a labeling of all tree nodes that minimizes the number of label differences ("mutations") over all tree edges.</p>
<p >Network parsimony generalizes the notion of parsimony from trees to networks.</p>
<p >We consider three types of small network parsimony problems the literature:</p>
<ul>
<li>hardwired parsimony</li>
<li>softwired parsimony</li>
<li>parental parsimony</li>
</ul>
<p >In all of these problems one is given a rooted network, i.e. a finite directed acyclic graph (DAG) \(G=(V,E)\) with one distinct root node \(v_r\) together with a labeling of the leaves (or generally a partial labeling \(\phi: V\rightarrow 2^C\). The task is to find a labeling of the nodes that minimizes a specific parsimony criterion.</p>
<p >In our considerations we follow the popular restriction to networks with indegree of at most two.</p>
<h1><a class="anchor" id="autotoc_md100"></a>
Hardwired parsimony</h1>
<p >Given a rooted network and partial node labeling, one minimizes the number of mutations over all directed edges of the network, i.e.</p>
<p >\(PS_{hardwired} = \min_\psi \sum_{(u,v)\in E} \psi(u)\neq\psi(v)\)</p>
<p >where \(\psi: V\rightarrow C\) s.t. \(\forall v\in V: \psi(v)\in\phi(v)\).</p>
<p >This is a formal extension of tree parsimony to networks; one accounts for mutations along all edges.</p>
<h1><a class="anchor" id="autotoc_md101"></a>
Softwired parsimony</h1>
<p >Given a rooted network and partial node labeling, one minimizes the number of mutations over all directed edges of a directed spanning tree of the network (which effectively selects a single parent for every reticulation node), i.e.</p>
<p >\(PS_{softwired} = \min_{\psi, T} \sum_{(u,v)\in E_T} \psi(u)\neq\psi(v),\)</p>
<p >where \(\psi: V\rightarrow C\) s.t. \(\forall v\in V: \psi(v)\in\phi(v)\).</p>
<p >The idea of this model is that the network specifies the set of potential phylogenetic trees over which one solves the small tree parsimony problem.</p>
<h1><a class="anchor" id="autotoc_md102"></a>
Parental parsimony</h1>
<p >This model considers the inheritance of allels in a polyploid setting. Characters can be mutated in children and/or collected from the ancestors (by allopoloploidy). (We present the problem from the lineage perspective!) Consequently, nodes are labeled by sets of characters.</p>
<p >\(PS_{parental} = \min_{f} \sum_{v\in V} \textrm{cost}_f(v),\)</p>
<p >where</p><ul>
<li>\(f: V\rightarrow 2^C\)</li>
<li>\(f(v_r) = 1\)</li>
<li>\(|f(v)| \leq \sum_{u\text{ parent of }v} |f(u)|\)</li>
<li>$\textrm{cost}_f(v) = |f(v) \setminus \bigcup_{u\textrm{ parent of }v} f(u)|$</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">import</span> infrared <span class="keyword">as</span> ir</div>
<div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</div>
<div class="line"><span class="keyword">import</span> random</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">class </span>DAG:</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;A simple class reprenting a rooted DAG</span></div>
<div class="line"><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">    </span></div>
<div class="line"><span class="stringliteral">    </span><span class="keyword">def </span>__init__(self, adjacency):</div>
<div class="line">        adjacency = {k:(v <span class="keywordflow">if</span> type(v)==list <span class="keywordflow">else</span> [v]) <span class="keywordflow">for</span> k,v <span class="keywordflow">in</span> adjacency.items()}</div>
<div class="line">    </div>
<div class="line">        nodes = set(adjacency.keys())</div>
<div class="line">        edges = []</div>
<div class="line">        <span class="keywordflow">for</span> x <span class="keywordflow">in</span> adjacency:</div>
<div class="line">            nodes.update(adjacency[x])</div>
<div class="line">            edges.extend((x,y) <span class="keywordflow">for</span> y <span class="keywordflow">in</span> adjacency[x])</div>
<div class="line">            </div>
<div class="line">        self._nodes = nodes</div>
<div class="line">        self._edges = edges</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># precompute parents, children, root</span></div>
<div class="line">        <span class="comment"># and perform some checks for &#39;proper&#39; DAG</span></div>
<div class="line">        self._parents=defaultdict(list)</div>
<div class="line">        <span class="keywordflow">for</span> u,v <span class="keywordflow">in</span> self._edges:</div>
<div class="line">            self._parents[v].append(u)</div>
<div class="line">    </div>
<div class="line">        self._children=defaultdict(list)</div>
<div class="line">        <span class="keywordflow">for</span> u,v <span class="keywordflow">in</span> self._edges:</div>
<div class="line">            self._children[u].append(v)</div>
<div class="line">    </div>
<div class="line">        <span class="comment"># find root</span></div>
<div class="line">        self._root = <span class="keywordtype">None</span></div>
<div class="line">        <span class="keywordflow">for</span> v <span class="keywordflow">in</span> self.nodes:</div>
<div class="line">            <span class="keywordflow">if</span> self.parents(v)==[]:</div>
<div class="line">                assert(self._root==<span class="keywordtype">None</span>)</div>
<div class="line">                self._root = v</div>
<div class="line">        assert(self._root!=<span class="keywordtype">None</span>)</div>
<div class="line"> </div>
<div class="line">    </div>
<div class="line">        assert(self._parents[self._root]==[])</div>
<div class="line">        <span class="keywordflow">for</span> node <span class="keywordflow">in</span> self._nodes:</div>
<div class="line">            <span class="keywordflow">if</span> node==self._root: <span class="keywordflow">continue</span></div>
<div class="line">            assert(self._parents[node]!=[])</div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>parents(self, node):</div>
<div class="line">        <span class="keywordflow">return</span> self._parents[node]</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>children(self, node):</div>
<div class="line">        <span class="keywordflow">return</span> self._children[node]</div>
<div class="line">        </div>
<div class="line">    @ property</div>
<div class="line">    <span class="keyword">def </span>root(self):</div>
<div class="line">        <span class="keywordflow">return</span> self._root</div>
<div class="line">        </div>
<div class="line">    @ property</div>
<div class="line">    <span class="keyword">def </span>edges(self):</div>
<div class="line">        <span class="keywordflow">return</span> self._edges</div>
<div class="line"> </div>
<div class="line">    @ property</div>
<div class="line">    <span class="keyword">def </span>nodes(self):</div>
<div class="line">        <span class="keywordflow">return</span> self._nodes</div>
<div class="line"> </div>
<div class="line">    @ property</div>
<div class="line">    <span class="keyword">def </span>reticulation_nodes(self):</div>
<div class="line">        <span class="keywordflow">return</span> [v <span class="keywordflow">for</span> v <span class="keywordflow">in</span> self._nodes <span class="keywordflow">if</span> len(self.parents(v))&gt;1]</div>
<div class="line">    </div>
<div class="line">    @ property</div>
<div class="line">    <span class="keyword">def </span>nonreticulation_nodes(self):</div>
<div class="line">        <span class="keywordflow">return</span> [v <span class="keywordflow">for</span> v <span class="keywordflow">in</span> self._nodes <span class="keywordflow">if</span> len(self.parents(v))==1]</div>
<div class="line"> </div>
<div class="line">    @ property</div>
<div class="line">    <span class="keyword">def </span>leaves(self):</div>
<div class="line">        <span class="keywordflow">return</span> [v <span class="keywordflow">for</span> v <span class="keywordflow">in</span> self._nodes <span class="keywordflow">if</span> self.children(v)==[]]</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>show(self, labels=None, shownames=False):</div>
<div class="line">        <span class="keyword">import</span> graphviz</div>
<div class="line">        </div>
<div class="line">        G=graphviz.Digraph(engine=<span class="stringliteral">&quot;dot&quot;</span>,</div>
<div class="line">            graph_attr=dict(),</div>
<div class="line">            node_attr=dict(fontsize=<span class="stringliteral">&quot;22pt&quot;</span>, fontname=<span class="stringliteral">&quot;Helvetica&quot;</span>,</div>
<div class="line">                           penwidth=<span class="stringliteral">&quot;3.0&quot;</span>, fontcolor=<span class="stringliteral">&quot;black&quot;</span>,</div>
<div class="line">                           shape=<span class="stringliteral">&quot;rectangle&quot;</span>, style=<span class="stringliteral">&quot;rounded&quot;</span>,</div>
<div class="line">                           height=<span class="stringliteral">&quot;0.4&quot;</span>, margin=<span class="stringliteral">&quot;0.03&quot;</span>),</div>
<div class="line">            edge_attr=dict(color=<span class="stringliteral">&quot;gray30&quot;</span>, penwidth=<span class="stringliteral">&quot;1.5&quot;</span>, arrowsize=<span class="stringliteral">&quot;0.8&quot;</span>))</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> v <span class="keywordflow">in</span> self.nodes:</div>
<div class="line">            <span class="keywordflow">try</span>:</div>
<div class="line">                label = labels[v]</div>
<div class="line">                assert(label!=<span class="keywordtype">None</span>)</div>
<div class="line">            <span class="keywordflow">except</span>:</div>
<div class="line">                label = <span class="stringliteral">&quot;&quot;</span></div>
<div class="line">            <span class="keywordflow">if</span> type(label)==set:</div>
<div class="line">                label=<span class="stringliteral">&#39;{&#39;</span>+<span class="stringliteral">&#39;,&#39;</span>.join(sorted(map(str,label)))+<span class="stringliteral">&#39;}&#39;</span></div>
<div class="line">            <span class="keywordflow">if</span> shownames:</div>
<div class="line">                label = f<span class="stringliteral">&quot;{v}:{label}&quot;</span></div>
<div class="line">                </div>
<div class="line">            color = <span class="stringliteral">&quot;gray30&quot;</span></div>
<div class="line">            <span class="keywordflow">if</span> len(self._parents[v])&gt;1: color=<span class="stringliteral">&quot;red&quot;</span></div>
<div class="line">            <span class="keywordflow">if</span> len(self._children[v])==0: color=<span class="stringliteral">&quot;blue&quot;</span></div>
<div class="line">        </div>
<div class="line">            G.node(str(v), label=str(label), color=color)</div>
<div class="line">        <span class="keywordflow">for</span> v,u <span class="keywordflow">in</span> self.edges:</div>
<div class="line">            G.edge(str(v),str(u))</div>
<div class="line">        <span class="keywordflow">return</span> G</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>print(self, labels):</div>
<div class="line">        <span class="keywordflow">for</span> v <span class="keywordflow">in</span> self.nodes:</div>
<div class="line">            print(f<span class="stringliteral">&#39;{v}\&#39;{labels[v]}\&#39; -&gt; {self.children(v)}&#39;</span>)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md103"></a>
An example input instance</h1>
<div class="fragment"><div class="line">characters = [<span class="stringliteral">&quot;A&quot;</span>,<span class="stringliteral">&quot;C&quot;</span>,<span class="stringliteral">&quot;G&quot;</span>,<span class="stringliteral">&quot;T&quot;</span>]</div>
<div class="line"><span class="keyword">def </span>a_to_cs(assignment):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Assignement to characters&quot;&quot;&quot;</span></div>
<div class="line">    <span class="keywordflow">return</span> [characters[x] <span class="keywordflow">for</span> x <span class="keywordflow">in</span> assignment.values()]</div>
<div class="line"> </div>
<div class="line"><span class="comment"># note: for building the model from our graph definition, we require that nodes are consecutive integers 0,1,2,3...</span></div>
<div class="line"> </div>
<div class="line">network = DAG({0:[1,2], 1:[3,4], 2:[4,5], 4:6, 3:[7,8], 6:[9,10], 5:[11,12]})</div>
<div class="line"> </div>
<div class="line">leaves = [<span class="stringliteral">&#39;A&#39;</span>,<span class="stringliteral">&#39;T&#39;</span>,<span class="stringliteral">&#39;T&#39;</span>,<span class="stringliteral">&#39;C&#39;</span>,<span class="stringliteral">&#39;G&#39;</span>,<span class="stringliteral">&#39;G&#39;</span>]</div>
<div class="line">leaves = {k:v <span class="keywordflow">for</span> k,v <span class="keywordflow">in</span> zip(network.leaves,leaves)}</div>
</div><!-- fragment --><div class="fragment"><div class="line">dot = network.show(leaves)</div>
<div class="line">dot.render(<span class="stringliteral">&#39;input-network&#39;</span>)</div>
<div class="line">dot</div>
</div><!-- fragment --><p ><img src="NetworkParsimony_files/NetworkParsimony_7_0.svg" alt="svg" style="pointer-events: none;" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md104"></a>
Model hardwired parsimony</h1>
<h2><a class="anchor" id="autotoc_md105"></a>
Define a hamming distance function between nodes</h2>
<div class="fragment"><div class="line">ir.def_function_class(<span class="stringliteral">&quot;Distance&quot;</span>,</div>
<div class="line">    <span class="keyword">lambda</span> u,v: [u,v],</div>
<div class="line">    <span class="keyword">lambda</span> psi_u,psi_v: psi_u != psi_v</div>
<div class="line">    )</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md106"></a>
Construct the model</h2>
<div class="fragment"><div class="line">model = ir.Model()</div>
<div class="line"> </div>
<div class="line">model.add_variables(len(network.nodes), len(characters))</div>
<div class="line">model.add_functions([Distance(u,v) <span class="keywordflow">for</span> u,v <span class="keywordflow">in</span> network.edges],</div>
<div class="line">                   <span class="stringliteral">&#39;score&#39;</span>)</div>
<div class="line"> </div>
<div class="line">model.set_feature_weight(-1, <span class="stringliteral">&#39;score&#39;</span>) <span class="comment"># -1, since we are minimizing</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># constrain leaves</span></div>
<div class="line"><span class="keywordflow">for</span> k,v <span class="keywordflow">in</span> leaves.items():</div>
<div class="line">    val = characters.index(v)</div>
<div class="line">    model.restrict_domains(k, (val,val))</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md107"></a>
Run optimization</h2>
<div class="fragment"><div class="line">optimizer = ir.Optimizer(model)</div>
<div class="line"> </div>
<div class="line">best_score = -optimizer.evaluate()</div>
<div class="line">best = optimizer.optimize()</div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&#39;Score: {best_score}&#39;</span>)</div>
<div class="line"> </div>
<div class="line">dot = network.show(a_to_cs(best))</div>
<div class="line">dot.render(<span class="stringliteral">&quot;hardwired-network&quot;</span>,view=<span class="keyword">False</span>)</div>
<div class="line">dot</div>
</div><!-- fragment --> <pre class="fragment">Score: 3.0
</pre><p ><img src="NetworkParsimony_files/NetworkParsimony_14_1.svg" alt="svg" style="pointer-events: none;" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md108"></a>
Model softwired parsimony with additional state (effectively keeps tree width!)</h1>
<h2><a class="anchor" id="autotoc_md109"></a>
Define hamming distance for reticualtions</h2>
<div class="fragment"><div class="line">ir.def_function_class(<span class="stringliteral">&quot;ReticulationDistance&quot;</span>,</div>
<div class="line">    <span class="keyword">lambda</span> u,v,x,y: [u, v, x],  <span class="comment"># u is the parent!, x is the selector variable, boolean y distinguishs between parents</span></div>
<div class="line">    <span class="keyword">lambda</span> psi_u, psi_v, valx, y: (psi_u != psi_v) <span class="keywordflow">and</span> valx==y</div>
<div class="line">    )</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md110"></a>
Construct model</h2>
<div class="fragment"><div class="line">model = ir.Model()</div>
<div class="line"> </div>
<div class="line">n=len(network.nodes)</div>
<div class="line"> </div>
<div class="line">model.add_variables(n, len(characters))</div>
<div class="line">model.add_functions([Distance(network.parents(v)[0],v)</div>
<div class="line">                     <span class="keywordflow">for</span> v <span class="keywordflow">in</span> network.nonreticulation_nodes],</div>
<div class="line">                    <span class="stringliteral">&#39;score&#39;</span>)</div>
<div class="line"> </div>
<div class="line">r = len(network.reticulation_nodes)</div>
<div class="line"><span class="comment"># add boolean selector variables (one for each reticulation nodes); indices n+1,...,n+r</span></div>
<div class="line">model.add_variables(r,2)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> parent <span class="keywordflow">in</span> range(2):</div>
<div class="line">    model.add_functions([ReticulationDistance(network.parents(v)[parent],v,n+i,parent)</div>
<div class="line">                         <span class="keywordflow">for</span> i,v <span class="keywordflow">in</span> enumerate(network.reticulation_nodes)],</div>
<div class="line">                        <span class="stringliteral">&#39;score&#39;</span>)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">model.set_feature_weight(-1, <span class="stringliteral">&#39;score&#39;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># constrain leaves</span></div>
<div class="line"><span class="keywordflow">for</span> k,v <span class="keywordflow">in</span> leaves.items():</div>
<div class="line">    val = characters.index(v)</div>
<div class="line">    model.restrict_domains(k, (val,val))</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md111"></a>
Run optimization</h2>
<div class="fragment"><div class="line"><span class="comment"># attention: currently, the default tree demposer of infrared might not yield the optimal result, since we added</span></div>
<div class="line"><span class="comment"># state variables. Here, we refrain from correcting this to keep things simple. Future versions of Infrared</span></div>
<div class="line"><span class="comment"># should address this properly.</span></div>
<div class="line"> </div>
<div class="line">optimizer = ir.Optimizer(model)</div>
<div class="line"> </div>
<div class="line">best_score = -optimizer.evaluate()</div>
<div class="line">best = optimizer.optimize()</div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&#39;Score: {best_score}&#39;</span>)</div>
<div class="line"> </div>
<div class="line">dot = network.show(a_to_cs(best))</div>
<div class="line">dot.render(<span class="stringliteral">&quot;softwired-network&quot;</span>,view=<span class="keyword">False</span>)</div>
<div class="line">dot</div>
</div><!-- fragment --> <pre class="fragment">Score: 3.0
</pre><p ><img src="NetworkParsimony_files/NetworkParsimony_21_1.svg" alt="svg" style="pointer-events: none;" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md112"></a>
Model softwired parsimony with ternary constraint</h1>
<h2><a class="anchor" id="autotoc_md113"></a>
Define hamming distance for reticualtions</h2>
<div class="fragment"><div class="line">ir.def_function_class(<span class="stringliteral">&quot;ReticulationDistance&quot;</span>,</div>
<div class="line">    <span class="keyword">lambda</span> u0,u1,v: [u0, u1, v],</div>
<div class="line">    <span class="keyword">lambda</span> psi_u0,psi_u1,psi_v: min(psi_u0 != psi_v,psi_u1 != psi_v)</div>
<div class="line">    )</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md114"></a>
Construct model</h2>
<div class="fragment"><div class="line">model = ir.Model()</div>
<div class="line"> </div>
<div class="line">model.add_variables(len(network.nodes), len(characters))</div>
<div class="line">model.add_functions([Distance(network.parents(v)[0],v)</div>
<div class="line">                     <span class="keywordflow">for</span> v <span class="keywordflow">in</span> network.nonreticulation_nodes],</div>
<div class="line">                    <span class="stringliteral">&#39;score&#39;</span>)</div>
<div class="line"> </div>
<div class="line">model.add_functions([ReticulationDistance(network.parents(v)[0],network.parents(v)[1],v)</div>
<div class="line">                     <span class="keywordflow">for</span> v <span class="keywordflow">in</span> network.reticulation_nodes],</div>
<div class="line">                    <span class="stringliteral">&#39;score&#39;</span>)</div>
<div class="line"> </div>
<div class="line">model.set_feature_weight(-1, <span class="stringliteral">&#39;score&#39;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># constrain leaves</span></div>
<div class="line"><span class="keywordflow">for</span> k,v <span class="keywordflow">in</span> leaves.items():</div>
<div class="line">    val = characters.index(v)</div>
<div class="line">    model.restrict_domains(k, (val,val))</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md115"></a>
Run optimization</h2>
<div class="fragment"><div class="line">optimizer = ir.Optimizer(model)</div>
<div class="line"> </div>
<div class="line">best_score = -optimizer.evaluate()</div>
<div class="line">best = optimizer.optimize()</div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&#39;Score: {best_score}&#39;</span>)</div>
<div class="line">network.show(a_to_cs(best))</div>
</div><!-- fragment --> <pre class="fragment">Score: 3.0
</pre><p ><img src="NetworkParsimony_files/NetworkParsimony_28_1.svg" alt="svg" style="pointer-events: none;" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md116"></a>
Model parental parsimony</h1>
<h2><a class="anchor" id="autotoc_md117"></a>
Model character sets as integer values</h2>
<div class="fragment"><div class="line"><span class="keyword">def </span>cs2v(cset):</div>
<div class="line">    val=0</div>
<div class="line">    <span class="keywordflow">for</span> i,c <span class="keywordflow">in</span> enumerate(characters):</div>
<div class="line">        <span class="keywordflow">if</span> c <span class="keywordflow">in</span> cset:</div>
<div class="line">            val += 2**i</div>
<div class="line">    <span class="keywordflow">return</span> val</div>
<div class="line">    </div>
<div class="line"><span class="keyword">def </span>v2cs(val):</div>
<div class="line">    x=set()</div>
<div class="line">    <span class="keywordflow">for</span> c <span class="keywordflow">in</span> characters:</div>
<div class="line">        <span class="keywordflow">if</span> val &amp; 1:</div>
<div class="line">            x.add(c)</div>
<div class="line">        val = val &gt;&gt; 1</div>
<div class="line">    <span class="keywordflow">return</span> x</div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>a_to_csets(assignment):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Assignment to characters sets&quot;&quot;&quot;</span></div>
<div class="line">    <span class="keywordflow">return</span> [v2cs(val) <span class="keywordflow">for</span> val <span class="keywordflow">in</span> assignment.values()]</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md118"></a>
Define distances on set labels</h2>
<div class="fragment"><div class="line">ir.def_function_class(<span class="stringliteral">&quot;SetDistance&quot;</span>,</div>
<div class="line">    <span class="keyword">lambda</span> u,v: [u, v],</div>
<div class="line">    <span class="keyword">lambda</span> f_u, f_v: len(v2cs(f_v)-v2cs(f_u)))</div>
<div class="line">ir.def_function_class(<span class="stringliteral">&quot;ReticulationSetDistance&quot;</span>,</div>
<div class="line">    <span class="keyword">lambda</span> u0, u1, v: [u0, u1, v],</div>
<div class="line">    <span class="keyword">lambda</span> f_u0, f_u1, f_v: len(v2cs(f_v)-v2cs(f_u0).union(v2cs(f_u1))))</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md119"></a>
Define constraint types</h2>
<div class="fragment"><div class="line">ir.def_constraint_class(<span class="stringliteral">&#39;SetSize&#39;</span>,</div>
<div class="line">    <span class="keyword">lambda</span> v,size: [v],</div>
<div class="line">    <span class="keyword">lambda</span> f_v, size: len(v2cs(f_v))==size)</div>
<div class="line"> </div>
<div class="line">ir.def_constraint_class(<span class="stringliteral">&#39;SetSizeRel&#39;</span>,</div>
<div class="line">    <span class="keyword">lambda</span> u,v: [u, v],</div>
<div class="line">    <span class="keyword">lambda</span> f_u, f_v: len(v2cs(f_v)) &lt;= len(v2cs(f_u)))</div>
<div class="line"> </div>
<div class="line">ir.def_constraint_class(<span class="stringliteral">&#39;ReticulationSetSizeRel&#39;</span>,</div>
<div class="line">    <span class="keyword">lambda</span> u0, u1, v: [u0, u1, v],</div>
<div class="line">    <span class="keyword">lambda</span> f_u0, f_u1, f_v: len(v2cs(f_v)) &lt;= len(v2cs(f_u0).union(v2cs(f_u1))))</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md120"></a>
Construct model</h2>
<div class="fragment"><div class="line">model = ir.Model()</div>
<div class="line"> </div>
<div class="line">model.add_variables(len(network.nodes), 2**len(characters))</div>
<div class="line"> </div>
<div class="line">model.add_constraints(SetSize(network.root,1))</div>
<div class="line"> </div>
<div class="line">model.add_constraints(SetSizeRel(network.parents(v)[0],v)</div>
<div class="line">    <span class="keywordflow">for</span> v <span class="keywordflow">in</span> network.nonreticulation_nodes)</div>
<div class="line"> </div>
<div class="line">model.add_constraints(ReticulationSetSizeRel(network.parents(v)[0],network.parents(v)[1],v)</div>
<div class="line">    <span class="keywordflow">for</span> v <span class="keywordflow">in</span> network.reticulation_nodes)</div>
<div class="line"> </div>
<div class="line">model.add_functions([SetDistance(network.parents(v)[0],v)</div>
<div class="line">                     <span class="keywordflow">for</span> v <span class="keywordflow">in</span> network.nonreticulation_nodes],</div>
<div class="line">                    <span class="stringliteral">&#39;score&#39;</span>)</div>
<div class="line"> </div>
<div class="line">model.add_functions([ReticulationSetDistance(network.parents(v)[0],network.parents(v)[1],v)</div>
<div class="line">                     <span class="keywordflow">for</span> v <span class="keywordflow">in</span> network.reticulation_nodes],</div>
<div class="line">                    <span class="stringliteral">&#39;score&#39;</span>)</div>
<div class="line"> </div>
<div class="line">model.set_feature_weight(-1, <span class="stringliteral">&#39;score&#39;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># constrain leaves</span></div>
<div class="line"><span class="keywordflow">for</span> k,v <span class="keywordflow">in</span> leaves.items():</div>
<div class="line">    val = cs2v(v)</div>
<div class="line">    model.restrict_domains(k, (val,val))</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md121"></a>
Run optimization</h2>
<div class="fragment"><div class="line">optimizer = ir.Optimizer(model)</div>
<div class="line"> </div>
<div class="line">best = optimizer.optimize()</div>
<div class="line">best_score = -optimizer.evaluate()</div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&#39;Score: {best_score}&#39;</span>)</div>
<div class="line">dot = network.show(a_to_csets(best))</div>
<div class="line">dot.render(<span class="stringliteral">&quot;parental-network&quot;</span>,view=<span class="keyword">False</span>)</div>
<div class="line">dot</div>
</div><!-- fragment --> <pre class="fragment">Score: 3.0
</pre><p ><img src="NetworkParsimony_files/NetworkParsimony_39_1.svg" alt="svg" style="pointer-events: none;" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md122"></a>
APPENDIX</h1>
<h1><a class="anchor" id="autotoc_md123"></a>
Grid networks</h1>
<p >Construct grid networks as a simple family of networks that allow us to enforce high tree width for decomposition.</p>
<div class="fragment"><div class="line"><span class="keyword">def </span>grid(n):</div>
<div class="line">    adj = defaultdict(list)</div>
<div class="line">    offset=0</div>
<div class="line">    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(n-1):</div>
<div class="line">        <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(offset,offset+i+1):</div>
<div class="line">            adj[j]=[j+i+1,j+i+2]</div>
<div class="line">        offset+=i+1</div>
<div class="line"> </div>
<div class="line">    offset0 = offset <span class="comment">#first &#39;parent&#39; in last row </span></div>
<div class="line">    offset+=n <span class="comment"># first node in constructed row</span></div>
<div class="line">    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> reversed(range(n-1)):</div>
<div class="line">        adj[offset0].append(offset)</div>
<div class="line">        <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(1,i+2):</div>
<div class="line">            adj[offset0+j-1].append(offset+j)</div>
<div class="line">            adj[offset0+j].append(offset+j)</div>
<div class="line">        adj[offset0+i+1].append(offset+i+2)</div>
<div class="line">        offset0 = offset+1</div>
<div class="line">        offset+=i+3</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> adj</div>
</div><!-- fragment --><div class="fragment"><div class="line">network=DAG(grid(4))</div>
<div class="line">leaves = {k:random.choice(characters) <span class="keywordflow">for</span> k <span class="keywordflow">in</span> network.leaves}</div>
<div class="line">network.show(leaves,shownames=<span class="keyword">True</span>)</div>
</div><!-- fragment --><p ><img src="NetworkParsimony_files/NetworkParsimony_42_0.svg" alt="svg" style="pointer-events: none;" class="inline"/></p>
<div class="fragment"><div class="line"><span class="comment">#construct and solve a hardwired model</span></div>
<div class="line">model = ir.Model()</div>
<div class="line"> </div>
<div class="line">model.add_variables(len(network.nodes), len(characters))</div>
<div class="line">model.add_functions([Distance(u,v) <span class="keywordflow">for</span> u,v <span class="keywordflow">in</span> network.edges],</div>
<div class="line">                   <span class="stringliteral">&#39;score&#39;</span>)</div>
<div class="line"> </div>
<div class="line">model.set_feature_weight(-1, <span class="stringliteral">&#39;score&#39;</span>) <span class="comment"># -1, since we are minimizing</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> k,v <span class="keywordflow">in</span> leaves.items():</div>
<div class="line">    val = characters.index(v)</div>
<div class="line">    model.restrict_domains(k, (val,val))</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment"># Run optimization</span></div>
<div class="line"> </div>
<div class="line">optimizer = ir.Optimizer(model)</div>
<div class="line"> </div>
<div class="line">print(<span class="stringliteral">&quot;TW:&quot;</span>,optimizer.treewidth())</div>
<div class="line"> </div>
<div class="line">best_score = -optimizer.evaluate()</div>
<div class="line">best = optimizer.optimize()</div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&#39;Score: {best_score}&#39;</span>)</div>
</div><!-- fragment --> <pre class="fragment">TW: 4
Score: 5.0
</pre><div class="fragment"><div class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> Image</div>
<div class="line"><span class="keyword">import</span> re</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment"># Plot dependency graph</span></div>
<div class="line">filename = <span class="stringliteral">&#39;dependency_graph.dot&#39;</span></div>
<div class="line">model.write_graph(filename, <span class="keyword">True</span>)</div>
<div class="line"> </div>
<div class="line">ir.dotfile_to_png(filename)</div>
<div class="line">filename = re.sub(<span class="stringliteral">r&quot;dot$&quot;</span>,<span class="stringliteral">&quot;png&quot;</span>,filename)</div>
<div class="line"> </div>
<div class="line">Image(filename=filename,width=300)</div>
</div><!-- fragment --><p ><img src="NetworkParsimony_files/NetworkParsimony_45_0.png" alt="png" class="inline"/></p>
<div class="fragment"><div class="line"><span class="comment"># Plot tree decomposition</span></div>
<div class="line">filename=<span class="stringliteral">&quot;treedecomp&quot;</span></div>
<div class="line">optimizer.plot_td(filename,<span class="stringliteral">&#39;png&#39;</span>)</div>
<div class="line">Image(filename=filename+<span class="stringliteral">&quot;.png&quot;</span>,width=400)</div>
</div><!-- fragment --><p ><img src="NetworkParsimony_files/NetworkParsimony_46_0.png" alt="png" class="inline"/></p>
<div class="fragment"><div class="line">network.show(a_to_cs(best))</div>
</div><!-- fragment --><p ><img src="NetworkParsimony_files/NetworkParsimony_47_0.svg" alt="svg" style="pointer-events: none;" class="inline"/></p>
<div class="fragment"></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
