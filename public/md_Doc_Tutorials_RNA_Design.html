<!-- HTML header for doxygen 1.9.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="$langISO">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Infrared: RNA Design Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<!-- $darkmode -->
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="style.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
  DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
  DoxygenAwesomeInteractiveToc.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
  DoxygenAwesomeParagraphLink.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
  DoxygenAwesomeFragmentCopyButton.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Infrared
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_Doc_Tutorials_RNA_Design.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">RNA Design Tutorial </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md46">Online resources and software environment</a></li>
<li class="level1"><a href="#autotoc_md48">Simple sampling of RNA sequences</a></li>
<li class="level1"><a href="#autotoc_md49">Adding complementarity constraints from an RNA secondary structure</a></li>
<li class="level1"><a href="#autotoc_md50">Controlling the GC content</a></li>
<li class="level1"><a href="#autotoc_md51">Controlling the BP energy</a></li>
<li class="level1"><a href="#autotoc_md52">Further constraints</a></li>
<li class="level1"><a href="#autotoc_md53">Targeting specific GC content and energy</a></li>
<li class="level1"><a href="#autotoc_md54">Targeting Turner energy</a></li>
<li class="level1"><a href="#autotoc_md55">Add IUPAC constraints</a></li>
</ul>
</div>
<div class="textblock"><hr  />
<h1><a class="anchor" id="autotoc_md46"></a>
Online resources and software environment</h1>
<p >​</p>
<p >This document is hosted online as <a href="https://www.lix.polytechnique.fr/~will/Software/Infrared/current/Doc/RNA%20Design.ipynb">Jupyter notebook</a> with precomputed results. Download this file to view, edit and run it in Jupyter.</p>
<p >​</p>
<p >We recommend to install all required software using Mamba (or Conda) and PIP.</p>
<div class="fragment"><div class="line">mamba create -n infrared -c conda-forge infrared jupyter jupytext matplotlib seaborn graphviz logomaker</div>
<div class="line"> </div>
<div class="line">mamba activate infrared</div>
<div class="line"> </div>
<div class="line"># optionally install the Vienna RNA package (only Linux or MacOS)</div>
<div class="line">mamba install -c conda-forge -c bioconda viennarna</div>
<div class="line"> </div>
<div class="line">pip install graphviz</div>
<div class="line"> </div>
<div class="line">mamba deactivate infrared</div>
</div><!-- fragment --><p >​</p>
<p >Start the Jupyter notebook server after activating the environment</p>
<div class="fragment"><div class="line">mamba activate infrared</div>
<div class="line"> </div>
<div class="line">jupyter notebook</div>
</div><!-- fragment --><p >The <a href="https://gitlab.inria.fr/amibio/Infrared/-/tree/master/Doc/Tutorials">original sources</a> are part of the Infrared distribution and hosted on Gitlab (in Jupytext light Script format).</p>
<p >​</p>
<hr  />
<h1><a class="anchor" id="autotoc_md48"></a>
Simple sampling of RNA sequences</h1>
<p >We start by importing the infrared module (and assign a shortname).</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> infrared <span class="keyword">as</span> ir</div>
</div><!-- fragment --><p >Let's specify our first constraint network model. It is <em>very</em> simple: we define 20 variables, each with 4 possible values, which encode a sequence of nucleotides. Our first model has no dependencies.</p>
<div class="fragment"><div class="line">model = ir.Model(20,4)</div>
</div><!-- fragment --><p >From this model, we directly construct a sampler.</p>
<div class="fragment"><div class="line">sampler = ir.Sampler(model)</div>
</div><!-- fragment --><p >Once initialized with a model, the sampler can prepare the sampling from this model. In particular, it computes a tree decomposition of the constraint network. In general, it is interesting to inspect the tree decomposition of a model's constraint network, since it guides the computation.</p>
<p >We define a function to display information on the tree decomposition.</p>
<div class="fragment"><div class="line"><span class="keyword">def </span>show_td_info(sampler,width=600):</div>
<div class="line">    td = sampler.td</div>
<div class="line">    print(<span class="stringliteral">&quot;tree width =&quot;</span>, td.treewidth())</div>
<div class="line">    print(<span class="stringliteral">&quot;bags =&quot;</span>, td.bags)</div>
<div class="line">    print(<span class="stringliteral">&quot;edges =&quot;</span>, td.edges)</div>
<div class="line">    </div>
<div class="line">    tmpfile=<span class="stringliteral">&quot;tmp_out.png&quot;</span></div>
<div class="line">    sampler.plot_td(tmpfile,<span class="stringliteral">&#39;png&#39;</span>)</div>
<div class="line">    <span class="keyword">from</span> IPython.display <span class="keyword">import</span> Image</div>
<div class="line">    <span class="keywordflow">return</span> Image(filename=tmpfile,width=width)</div>
</div><!-- fragment --><p >When we now call this function on our sampler, we will see that so far our model has a trivial tree decomposition (as expected, since we didn't add any constraints or functions to our model).</p>
<div class="fragment"><div class="line">show_td_info(sampler)</div>
</div><!-- fragment --> <pre class="fragment">tree width = 0
bags = [[5], [14], [10], [1], [6], [12], [16], [18], [9], [0], [3], [8], [2], [7], [15], [19], [17], [4], [11], [13]]
edges = [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 9), (0, 10), (0, 11), (0, 12), (0, 13), (0, 14), (0, 15), (0, 16), (0, 17), (0, 18), (0, 19)]
</pre><p ><img src="RNA%20Design_files/RNA%20Design_11_1.png" alt="png" class="inline"/></p>
<p >Nevertheless, we can evaluate the cluster tree.</p>
<p >In this simple case, this will count the nucleotide sequences of length 20 (i.e. we expect to see a count of 4**20).</p>
<div class="fragment"><div class="line">count = sampler.evaluate()</div>
<div class="line">print(<span class="stringliteral">&quot;# =&quot;</span>,int(count))</div>
</div><!-- fragment --> <pre class="fragment"># = 1099511627776
</pre><p >Next, let's draw 10 samples. These samples encode uniformly drawn sequences of length 20.</p>
<div class="fragment"><div class="line">samples = [sampler.sample().values() <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(10)]</div>
<div class="line">samples</div>
</div><!-- fragment --><pre class="fragment">[[0, 0, 0, 0, 2, 1, 0, 2, 2, 0, 3, 1, 1, 2, 0, 2, 0, 3, 3, 3],
 [3, 3, 1, 2, 1, 2, 3, 3, 3, 1, 0, 2, 1, 3, 3, 1, 1, 2, 3, 2],
 [3, 3, 1, 0, 2, 2, 1, 0, 0, 3, 2, 0, 2, 0, 2, 0, 1, 3, 3, 1],
 [0, 3, 2, 2, 3, 2, 0, 2, 1, 1, 1, 1, 1, 0, 2, 1, 3, 3, 3, 2],
 [0, 1, 2, 1, 3, 3, 2, 3, 3, 3, 2, 2, 3, 2, 1, 1, 0, 1, 3, 3],
 [0, 1, 0, 0, 0, 3, 2, 1, 3, 1, 2, 1, 3, 1, 1, 2, 3, 0, 3, 1],
 [3, 2, 0, 0, 0, 1, 3, 3, 2, 0, 2, 2, 0, 0, 3, 0, 0, 0, 2, 2],
 [3, 0, 1, 2, 0, 2, 3, 0, 3, 0, 3, 0, 0, 3, 0, 0, 3, 2, 0, 0],
 [2, 3, 3, 1, 3, 3, 2, 1, 3, 2, 1, 0, 0, 0, 3, 0, 2, 2, 1, 0],
 [2, 3, 3, 3, 2, 2, 0, 3, 3, 3, 3, 2, 1, 3, 0, 3, 2, 0, 3, 2]]
</pre><p >... and show them more pretty.</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> infrared <span class="keyword">import</span> rna</div>
<div class="line">[rna.values_to_seq(s) <span class="keywordflow">for</span> s <span class="keywordflow">in</span> samples]</div>
</div><!-- fragment --><pre class="fragment">['AAAAGCAGGAUCCGAGAUUU',
 'UUCGCGUUUCAGCUUCCGUG',
 'UUCAGGCAAUGAGAGACUUC',
 'AUGGUGAGCCCCCAGCUUUG',
 'ACGCUUGUUUGGUGCCACUU',
 'ACAAAUGCUCGCUCCGUAUC',
 'UGAAACUUGAGGAAUAAAGG',
 'UACGAGUAUAUAAUAAUGAA',
 'GUUCUUGCUGCAAAUAGGCA',
 'GUUUGGAUUUUGCUAUGAUG']
</pre><h1><a class="anchor" id="autotoc_md49"></a>
Adding complementarity constraints from an RNA secondary structure</h1>
<p >We define a toy RNA secondary structure (in dot-bracket notation)</p>
<div class="fragment"><div class="line">structure = <span class="stringliteral">&quot;((((...))))(((...)))&quot;</span></div>
</div><!-- fragment --><p >... and parse it.</p>
<div class="fragment"><div class="line">bps = rna.parse(structure)</div>
<div class="line">print(bps)</div>
</div><!-- fragment --> <pre class="fragment">[(0, 10), (1, 9), (2, 8), (3, 7), (11, 19), (12, 18), (13, 17)]
</pre><p >Next, we define the class of complementarity constraints; we call it BPComp for base pair complementarity. Each such constraint is constructed for two specific positions i and j. Then, the constraint is checked by testing whether the values x and y at the respective positions i and j correspond to complementary base pairs.</p>
<div class="fragment"><div class="line">ir.def_constraint_class( </div>
<div class="line">    <span class="stringliteral">&#39;BPComp&#39;</span>,</div>
<div class="line">    <span class="keyword">lambda</span> i,j: [i,j],</div>
<div class="line">    <span class="keyword">lambda</span> x,y: rna.values_to_seq([x,y]) </div>
<div class="line">                  <span class="keywordflow">in</span> [<span class="stringliteral">&quot;AU&quot;</span>,<span class="stringliteral">&quot;CG&quot;</span>,<span class="stringliteral">&quot;GC&quot;</span>,<span class="stringliteral">&quot;GU&quot;</span>,<span class="stringliteral">&quot;UA&quot;</span>,<span class="stringliteral">&quot;UG&quot;</span>]</div>
<div class="line">)    </div>
</div><!-- fragment --><p >Btw, there is already a pre-defined constraint rna.BPComp, which we could have used as well.</p>
<p >From the parsed structure, we generate a set of complementarity constraints - one for each base pair.</p>
<div class="fragment"><div class="line">cons = [ BPComp( i , j ) <span class="keywordflow">for</span> (i,j) <span class="keywordflow">in</span> bps ]</div>
</div><!-- fragment --><p >For illustrations, let's also print the variables of the constraints.</p>
<div class="fragment"><div class="line">[c.vars() <span class="keywordflow">for</span> c <span class="keywordflow">in</span> cons]</div>
</div><!-- fragment --><pre class="fragment">[[0, 10], [1, 9], [2, 8], [3, 7], [11, 19], [12, 18], [13, 17]]
</pre><p >Now, we are ready to construct the new constraint model, including the new constraints, and construct the corresponding sampler.</p>
<div class="fragment"><div class="line">seqlen = len(structure) <span class="comment"># --&gt; number of positions / variables in the CN</span></div>
<div class="line">model = ir.Model(seqlen,4)</div>
<div class="line">model.add_constraints(cons)</div>
<div class="line"> </div>
<div class="line">sampler = ir.Sampler(model)</div>
</div><!-- fragment --><p >Let's first see whether the tree decomposition looks more interesting this time.</p>
<div class="fragment"><div class="line">show_td_info(sampler)</div>
</div><!-- fragment --> <pre class="fragment">tree width = 1
bags = [[19, 11], [9], [1, 9], [8], [8, 2], [10], [0, 10], [18], [12, 18], [13], [17, 13], [7], [3, 7], [5], [15], [4], [16], [14], [6], [19]]
edges = [(0, 1), (0, 3), (0, 5), (0, 7), (0, 9), (0, 11), (0, 13), (0, 14), (0, 15), (0, 16), (0, 17), (0, 18), (1, 2), (3, 4), (5, 6), (7, 8), (9, 10), (11, 12), [19, 0]]
</pre><p ><img src="RNA%20Design_files/RNA%20Design_33_1.png" alt="png" class="inline"/></p>
<p >As expected, the tree decomposition reflects the dependencies due to the new constraints.</p>
<p >When we evaluate the model, we obtain the number of sequences that are compatbile with our secondary structure (doing simple combinatorics, we expect \(6^7 * 6^4\)).</p>
<div class="fragment"><div class="line">count = sampler.evaluate()</div>
<div class="line">print(<span class="stringliteral">&quot;# =&quot;</span>,int(count))</div>
</div><!-- fragment --> <pre class="fragment"># = 1146617856
</pre><p >It's time to generate samples again. Before this get's boring, we quickly define a function to automatize this. For the fun of it, let's also draw sequence logos from the samples.</p>
<p ><b>Note</b>: logos will be drawn only if the modules <code>logomaker</code> and <code>matplotlib.pyplot</code> are properly installed.</p>
<div class="fragment"><div class="line"><span class="keyword">def </span>draw_logo(sequences):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Draw sequence logo for a set of sequences&quot;&quot;&quot;</span></div>
<div class="line">    <span class="keyword">import</span> logomaker <span class="keyword">as</span> lm</div>
<div class="line">    <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div>
<div class="line">        </div>
<div class="line">    matrix = lm.alignment_to_matrix(sequences = sequences)</div>
<div class="line">    logo = lm.Logo(matrix)</div>
<div class="line">    logo.style_xticks(rotation=90, fmt=<span class="stringliteral">&#39;%d&#39;</span>, anchor=0)</div>
<div class="line">    logo.ax.xaxis.set_ticks_position(<span class="stringliteral">&#39;none&#39;</span>)</div>
<div class="line">    plt.savefig(<span class="stringliteral">&#39;test.svg&#39;</span>)</div>
<div class="line">    plt.show()</div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>opt_draw_logo(sequences):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Draw sequence logo, only if required modules are available&quot;&quot;&quot;</span> </div>
<div class="line">    <span class="keywordflow">try</span>:</div>
<div class="line">        draw_logo(sequences)</div>
<div class="line">    <span class="keywordflow">except</span> ModuleNotFoundError:</div>
<div class="line">        <span class="keywordflow">pass</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>spit_them_samples_out(sampler,num,structure=None):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Generate and show samples&quot;&quot;&quot;</span></div>
<div class="line">    samples = [ sampler.sample() <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(num) ]</div>
<div class="line">    sequences =  [ rna.ass_to_seq(s) <span class="keywordflow">for</span> s <span class="keywordflow">in</span> samples ]</div>
<div class="line">    <span class="keywordflow">if</span> structure: print(structure)</div>
<div class="line">    <span class="keywordflow">for</span> s <span class="keywordflow">in</span> sequences: print(s)</div>
<div class="line">    opt_draw_logo(sequences)</div>
</div><!-- fragment --><p >Generate samples and print them with the given structure; we can see that the base pair constraints are satisfied by all samples.</p>
<div class="fragment"><div class="line">spit_them_samples_out(sampler,20,structure)</div>
</div><!-- fragment --> <pre class="fragment">((((...))))(((...)))
GUAUCAGAUGCCUCACGGGG
AUCAAGCUGGUACUUCCAGU
CAGAGCCUCUGGCUAGGGGU
GGGGCCGCUUCUAUGUGAUA
UAUGUACUAUGUGCUUUGUA
CGUCGACGACGUGUCGAGCG
CUGCCGUGCGGGUAUCCUAU
GAGCAGGGUUCCAGUUCCUG
GUAGUACUUACAGAACUUUU
CCGAAUUUCGGGUAACAUGC
UCUAUAGUGGGUAGGAACUG
GCGUAGGACGCGGUUACGCC
CUUUGGCGGGGCAUCCCGUG
UUGUGACACGACGCGAUGUG
UGGUCAGAUUGGAUUUGGUC
GGUGGUGUGUUGAGUUCUUC
CGGUUGCGUUGGCGAUUUGC
UUCUCCGAGGGUUCAGUGAA
GGUAAUGUGCUUGGGGAUUA
UCCACUUUGGGAGUUUAGCU


Matplotlib is building the font cache; this may take a moment.
</pre><p ><img src="RNA%20Design_files/RNA%20Design_40_2.png" alt="png" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md50"></a>
Controlling the GC content</h1>
<p >To control features of our samples like the GC content, we are going to add suitable functions to our model. For the GC control, we define the function class <code>GCCont</code>, which let us count the Gs and Cs in the encoded sequence. For a specific position i, the function returns 1 if the encoded nucleotide is G or C; otherwise, 0.</p>
<div class="fragment"><div class="line">ir.def_function_class(</div>
<div class="line">    <span class="stringliteral">&#39;GCCont&#39;</span>,</div>
<div class="line">    <span class="keyword">lambda</span> i: [i],</div>
<div class="line">    <span class="keyword">lambda</span> x: rna.value_to_nucleotide( x ) <span class="keywordflow">in</span> <span class="stringliteral">&quot;GC&quot;</span></div>
<div class="line">)</div>
</div><!-- fragment --><p >Btw, this function is as well pre-defined in Infrared's rna support module as <code>rna.GCCont</code>.</p>
<p >GC-control is added to the sampler, simply by specifying the set of functions (<code>gc_funs</code>), adding them to the sampler as a function group &lsquo;'gc&rsquo;`, and setting the weight of the corresponding (automatically generated) feature of the same name.</p>
<p >Note how the new functions can simply be added to the existing model with base pair complementarity constraints. This provides a first good example of the compositional construction of models in Infrared.</p>
<div class="fragment"><div class="line">gc_weight = 0.12 <span class="comment"># &lt;- try different weights: -0.1, 0, 0.1, ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># define set of GCCont functions</span></div>
<div class="line">gc_funs = [ GCCont( i )</div>
<div class="line">              <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range( seqlen ) ]</div>
<div class="line"> </div>
<div class="line"><span class="comment"># add functions as group &#39;gc&#39; </span></div>
<div class="line">model.add_functions(gc_funs, <span class="stringliteral">&#39;gc&#39;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># set the weight of the &#39;gc&#39; feature</span></div>
<div class="line">model.set_feature_weight(gc_weight, <span class="stringliteral">&#39;gc&#39;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># construct sampler</span></div>
<div class="line">sampler = ir.Sampler( model )</div>
<div class="line"> </div>
<div class="line"><span class="comment"># generate samples</span></div>
<div class="line">spit_them_samples_out( sampler, 10, structure )</div>
</div><!-- fragment --> <pre class="fragment">((((...))))(((...)))
UGGGAACUCUAAGUGUAAUU
CCUGCUCUGGGUGAUAUUUA
UACUCGAGGUGUGAUAAUCA
UAGGCCCCUUACGGCCUUCG
CUUUAUUAAAGAUAGCUUGU
UGUCUGAGGCGUGCAUUGCA
GGUCCGAGAUCCGCAUGGCG
GAGAGUGUUUUGCGGCUUGC
GCAAGAUUUGUAGACCGUCU
AACUACGAGUUUUAGUGUGA
</pre><p ><img src="RNA%20Design_files/RNA%20Design_44_1.png" alt="png" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md51"></a>
Controlling the BP energy</h1>
<p >Next, we are going to introduce functions to compute the energy our secondary structure for the enoded sequence. To express energy in the base pair energy model, we are going to define a set of functions of the pre-defined type <code>rna.BPEnergy</code>; one for each base pair.</p>
<div class="fragment"><div class="line">bpe_funs = [ rna.BPEnergy( i, j, <span class="keyword">False</span> ) <span class="keywordflow">for</span> (i,j) <span class="keywordflow">in</span> bps ] </div>
</div><!-- fragment --><p >These functions are added to the existing model, as the GC functions before. We put them into a new function group &lsquo;'energy&rsquo;`, which will immediately allow us to control them (in addition to the GC content) through the automatically generated feature &lsquo;'energy&rsquo;`.</p>
<div class="fragment"><div class="line">model.add_functions(bpe_funs, <span class="stringliteral">&#39;energy&#39;</span>)</div>
</div><!-- fragment --><p >Let's set weights of our two features and generate samples. By setting a negative weight for energy, we aim at low energy for the structure. The GC control allows us to counter-act the induced shift towards high GC content. For the latter purpose, we set a negative weight to aim at lower GC content.</p>
<div class="fragment"><div class="line">model.set_feature_weight(-0.5, <span class="stringliteral">&#39;gc&#39;</span>)</div>
<div class="line">model.set_feature_weight(-1, <span class="stringliteral">&#39;energy&#39;</span>)</div>
<div class="line"> </div>
<div class="line">sampler = ir.Sampler(model)</div>
<div class="line"> </div>
<div class="line">spit_them_samples_out(sampler, 10, structure)</div>
</div><!-- fragment --> <pre class="fragment">((((...))))(((...)))
CGAGUUCCUCGAGGAUUCCU
CCCACGUUGGGAGUGAUACU
CUGGUUACUAGUUCGAUGAG
CAGUCUUGCUGGUCCCAGGC
AGGCAAUGCUUGCGAUUCGU
GGUUAUGAACUUGCUGAGCG
CGUGAUCCGCGGCCACCGGC
GCUCUUCGAGCUCCCCGGGA
UGCCAAGGGCAGUCUGUGGU
CGGCUCGGCUGGGGACACCC
</pre><p ><img src="RNA%20Design_files/RNA%20Design_50_1.png" alt="png" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md52"></a>
Further constraints</h1>
<p >We can even extend the model by further constraints, while maintaining the ability to control the features. As example of additional hard constraints, we are going to avoid GG dinucleotides. Extending the model by such additional constraints, expectedly, goes through the steps of</p>
<ul>
<li>defining the new constraint type</li>
<li>defining a set of constraints</li>
<li>adding the set to the model</li>
</ul>
<div class="fragment"><div class="line">ir.def_constraint_class(<span class="stringliteral">&#39;AvoidGGConstraint&#39;</span>,</div>
<div class="line">                         <span class="keyword">lambda</span> i: [i, i+1],</div>
<div class="line">                         <span class="keyword">lambda</span> x,y: rna.values_to_seq([x,y]) != <span class="stringliteral">&quot;GG&quot;</span>)</div>
<div class="line"> </div>
<div class="line">gg_cons = [ AvoidGGConstraint( i ) <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(seqlen-1) ]</div>
<div class="line"> </div>
<div class="line">model.add_constraints(gg_cons)</div>
</div><!-- fragment --><p >Finally, we construct the sampler for the extended model and generate samples.</p>
<div class="fragment"><div class="line">sampler = ir.Sampler(model)</div>
<div class="line"> </div>
<div class="line">spit_them_samples_out(sampler, 10, structure)</div>
</div><!-- fragment --> <pre class="fragment">((((...))))(((...)))
AGCGUGUCGUUAGCGAAGCU
AGUUAAAAGCUUAUGCCAUA
CGACUAUGUCGUGAAUAUCA
GAAAAGAUUUUUUGUCCCAA
CAAUAUAAUUGUGUUUUACG
UUAGAAUCUAGUAAUACUUA
GUCGUGCCGACUAAUCGUUA
GAGACAAUCUCGAUGAUGUU
UGAGCACUUCAGUGAAUCAC
UACUCCCAGUGCGAAUGUCG
</pre><p ><img src="RNA%20Design_files/RNA%20Design_54_1.png" alt="png" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md53"></a>
Targeting specific GC content and energy</h1>
<p >The previous model allowed to control the mean GC content and base pair energy of the produced model by manually tweaking the weights.</p>
<p >This leaves several challenges if we would want to produce samples with defined GC content and energy:</p>
<ul>
<li>we would have to filter the generated samples for a specific tolerance range around the targeted values</li>
<li>the features are not independent, thus changing one weight requires changing the other - this would get even harder for more than two features.</li>
</ul>
<p >Infrared supports these goals in a general way by implementing a multi-dimensional Boltzmann sampling strategy.</p>
<p >For this purpose, first set up the model and sampler as before.</p>
<div class="fragment"><div class="line">model =  ir.Model(seqlen, 4)</div>
<div class="line">model.add_constraints(cons)</div>
<div class="line">model.add_functions(bpe_funs, <span class="stringliteral">&#39;energy&#39;</span>)</div>
<div class="line">model.add_functions(gc_funs, <span class="stringliteral">&#39;gc&#39;</span>)</div>
<div class="line"> </div>
<div class="line">sampler = ir.Sampler( model )</div>
</div><!-- fragment --><p >Infrared now allows to set target values and tolerances for all (or selected) features and then produce targeted samples using the method <code>Sampler.targeted_sample()</code>.</p>
<p >In the code below, we print samples with their energy and GC-content. Note how we obtain these values simply by asking the model to evaluate the features for the sample.</p>
<div class="fragment"><div class="line">sampler.set_target( -12, 1, <span class="stringliteral">&#39;energy&#39;</span> )</div>
<div class="line">sampler.set_target( 10, 2, <span class="stringliteral">&#39;gc&#39;</span> )</div>
<div class="line"> </div>
<div class="line">samples = list()</div>
<div class="line"><span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(20):</div>
<div class="line">    sample = sampler.targeted_sample()</div>
<div class="line">    sequence = rna.ass_to_seq(sample)</div>
<div class="line">    print(<span class="stringliteral">&quot;{} {:.2f} {:.2f}&quot;</span>.format(sequence, </div>
<div class="line">                                    model.eval_feature(sample,<span class="stringliteral">&#39;energy&#39;</span>),</div>
<div class="line">                                    model.eval_feature(sample,<span class="stringliteral">&#39;gc&#39;</span>)))</div>
<div class="line">    samples.append(sequence)</div>
<div class="line">opt_draw_logo(samples)</div>
</div><!-- fragment --> <pre class="fragment">CCGUACAGCGGUCGUAACGA -11.92 12.00
GGGGCUUCUCCCGGAUUUUG -11.06 12.00
GGCGCAACGCCAGAUUGUCU -11.56 12.00
UGGGAUUCUCGGGGAAGUCC -11.06 12.00
CGCCUCAGGCGGGUAAUGUU -11.06 12.00
CCCCUUCGGGGAACAUAGUU -11.56 11.00
GUUCAAGGGGCGGUAUUGCC -11.06 12.00
UUGCAAAGUGGGGGACACCC -11.06 12.00
UUGCACAGCGACGCAAAGCG -11.92 12.00
CUGCGUUGUGGUGGAUUCCG -11.06 12.00
GGAUAAAAUCCCCCAAUGGG -11.56 10.00
CCUAUAUUAGGCCGCAACGG -11.56 11.00
UCCCAAUGGGAACGACUCGU -11.56 11.00
UUGGCUUCCAGGCCAAUGGC -11.92 12.00
CGUGAAUCACGGGUUGUACC -11.56 11.00
AGGUGUAACCUGCGUUGCGC -11.56 12.00
GUGGUUACCACCACGCUGUG -11.56 12.00
AGCGAAGCGUUCGGAUUCCG -11.92 12.00
CUCUUCUGGGGGGGUUACCU -11.06 12.00
GAGAAUCUCUCGGGAAACCC -11.56 11.00
</pre><p ><img src="RNA%20Design_files/RNA%20Design_58_1.png" alt="png" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md54"></a>
Targeting Turner energy</h1>
<p >Finally, for real applications, it is typically much more relevant to target specific Turner energy than specific energy in the simple base pair model. In Infrared, we solve this by defining and adding a new feature &lsquo;'Energy&rsquo;<code>to the model that calculates Turner energy (by calling a function of the Vienna RNA package). In addition to defining this calculation, we specify as well that the new feature should control the function group</code>energy`. In this way, Infrared will use base pair energy as proxy of Turner energy.</p>
<p ><b>Note:</b> this requires the Vienna RNA package with working Python bindings (currently, this fails in Windows even after installing the package from binaries)</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> RNA</div>
<div class="line"> </div>
<div class="line">model.add_feature( <span class="stringliteral">&#39;Energy&#39;</span>, <span class="comment"># feature name</span></div>
<div class="line">                   <span class="stringliteral">&#39;energy&#39;</span>, <span class="comment"># controlled group(s)</span></div>
<div class="line">                   <span class="comment">#</span></div>
<div class="line">                   <span class="comment"># function to evaluate the feature for a sample;</span></div>
<div class="line">                   <span class="comment"># NOTE how we have to bind i</span></div>
<div class="line">                   <span class="keyword">lambda</span> sample, structure=structure:</div>
<div class="line">                      RNA.energy_of_struct( rna.ass_to_seq( sample ),</div>
<div class="line">                                            structure )</div>
<div class="line">                 )</div>
</div><!-- fragment --><p >As before, we set targets and generate samples. Of course, this time, we set a target range for the new feature of Turner energy.</p>
<div class="fragment"><div class="line">sampler = ir.Sampler(model)</div>
<div class="line"> </div>
<div class="line">sampler.set_target( -5, 1, <span class="stringliteral">&#39;Energy&#39;</span> )</div>
<div class="line">sampler.set_target( 10, 2, <span class="stringliteral">&#39;gc&#39;</span> )</div>
<div class="line"> </div>
<div class="line">samples = list()</div>
<div class="line"><span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(20):</div>
<div class="line">    sample = sampler.targeted_sample()</div>
<div class="line">    print(<span class="stringliteral">&quot;{} {:5.2f} {:5.2f} {:5.2f}&quot;</span>.format(rna.ass_to_seq(sample), </div>
<div class="line">                                    model.eval_feature(sample,<span class="stringliteral">&#39;energy&#39;</span>),</div>
<div class="line">                                    model.eval_feature(sample,<span class="stringliteral">&#39;Energy&#39;</span>),</div>
<div class="line">                                    model.eval_feature(sample,<span class="stringliteral">&#39;gc&#39;</span>)))</div>
<div class="line">    samples.append(rna.ass_to_seq(sample))</div>
<div class="line"> </div>
<div class="line">opt_draw_logo(samples)</div>
</div><!-- fragment --> <pre class="fragment">CCGCUAAGCGGACCUUAGGU -13.14 -4.80 12.00
GGUGAUCCACCGGACAAUCC -11.56 -4.00 12.00
GUCUGAUGGACGGCUAUGCC -11.92 -4.10 12.00
GACUUAUGGUCGCCUUGGGC -11.92 -4.10 12.00
GGCCUUUGGCCGACCUUGUU -11.92 -4.20 12.00
CCCAGAUUGGGGGCUAAGCU -11.92 -4.10 12.00
GGCAUUUUGCCGCCAUGGGU -11.92 -4.80 12.00
GGCUUUCAGCCGCUAAAGGC -11.92 -4.50 12.00
GAGGUCUCCUCAGCUAUGCU -11.56 -4.00 11.00
CCCCAUUGGGGGGAAAAUCC -13.14 -5.60 12.00
CCCCUAUGGGGCACAAAGUG -13.14 -4.00 12.00
UGCCAAUGGCACGCUAUGCG -13.14 -4.30 12.00
GCCCGUUGGGCGGAAAAUCU -11.92 -4.70 12.00
GCGGUAACCGCACCAAAGGU -13.14 -5.30 12.00
GGGUAGAACCCAGCCAUGCU -11.56 -4.50 12.00
CCCGUAACGGGGCUUAUAGC -13.14 -4.50 12.00
GUCAAAAUGACGCCACGGGC -11.56 -4.10 12.00
GGUGUAUCACCGGCAUAGCC -13.14 -5.50 12.00
GGGCCUCGCCCGUAUAAUAC -11.56 -4.20 12.00
CCAGUUUCUGGGCCAAAGGC -13.14 -4.70 12.00
</pre><p ><img src="RNA%20Design_files/RNA%20Design_62_1.png" alt="png" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md55"></a>
Add IUPAC constraints</h1>
<p >In many design applications, we have prior knowledge on the sequences, which can be encoded as IUPAC string. Below, we generate constraints from a IUPAC string and add them to the Infrared model for targeting Turner energy and GC content.</p>
<div class="fragment"><div class="line">sequence = <span class="stringliteral">&quot;RSSSUWWSSNNSNNNNMNYR&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> i,x <span class="keywordflow">in</span> enumerate(sequence):</div>
<div class="line">    model.add_constraints(ir.ValueIn(i,rna.iupacvalues(x)))</div>
<div class="line"> </div>
<div class="line">sampler = ir.Sampler(model)</div>
<div class="line"> </div>
<div class="line">sampler.set_target( -5, 1, <span class="stringliteral">&#39;Energy&#39;</span> )</div>
<div class="line">sampler.set_target( 10, 2, <span class="stringliteral">&#39;gc&#39;</span> )</div>
<div class="line"> </div>
<div class="line">samples = list()</div>
<div class="line"><span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(20):</div>
<div class="line">    sample = rna.ass_to_seq(sampler.targeted_sample())</div>
<div class="line">    print(sample)</div>
<div class="line">    samples.append(sample)</div>
<div class="line">    </div>
<div class="line">opt_draw_logo(samples)</div>
</div><!-- fragment --> <pre class="fragment">GGGCUUUGCCCCAGUAACUG
GGCCUAAGGCCCACUUAGUG
GGGCUUAGCCCCGAAUAUCG
GGGGUAACCCCCACUAAGUG
GCCCUAUGGGCCACAUAGUG
GCCCUAAGGGCCGUAUAACG
GGGCUUUGCCCCGUAUAACG
GGCCUAAGGCCCGUAUAACG
GCCCUUAGGGCCAGUAACUG
GGGGUAUCCCCCGAAAAUCG
GCCCUAUGGGCCGUUUAACG
GGGCUUUGCCCCGAAUAUCG
GGGGUAUCCCCCGAAUAUCG
GGGCUUAGCCCCGAAUAUCG
GGGGUAACCCCCGAAAAUCG
GGGGUUUCCCCCAGAAACUG
GGCCUAUGGCCCACUAAGUG
GGGCUAUGCCCCGAUAAUCG
GGGCUUUGCCCCACAAAGUG
GCCCUUUGGGCCGAAUAUCG
</pre><p ><img src="RNA%20Design_files/RNA%20Design_64_1.png" alt="png" class="inline"/></p>
<p ><b>Remark:</b> At this point, we have implemented the full functionality of the RNA design approach IncaRNAtion (Reinharz et al., Bioinformatics 2013) in Infrared. In Infrared, we can easily extend the model further by including further constraints and going on to multi-target design. Infrared makes the latter, which extends functionality to the tool RNARedPrint (Hammer et al; BMC Bioinf 2021), look surprisingly simple. (We demonstrate this in a separate accompanying notebook, as well as in the Infrared-based application RNARedPrint 2). </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
