<!-- HTML header for doxygen 1.9.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="$langISO">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Infrared: Alignment</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<!-- $darkmode -->
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="style.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
  DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
  DoxygenAwesomeInteractiveToc.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
  DoxygenAwesomeParagraphLink.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
  DoxygenAwesomeFragmentCopyButton.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Infrared
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_Doc_Examples_Alignment.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Alignment </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md169">Online resources and software environment</a></li>
<li class="level1"><a href="#autotoc_md171">The alignment problem</a></li>
<li class="level1"><a href="#autotoc_md172">Problem input and test instances</a></li>
<li class="level1"><a href="#autotoc_md173">Specialized tree decomposition</a></li>
<li class="level1"><a href="#autotoc_md174">Showing information on the tree decomposition</a></li>
<li class="level1"><a href="#autotoc_md175">Represent alignments as objects</a><ul><li class="level2"><a href="#autotoc_md176">... and define the scoring scheme in a class</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md177">Expressing the alignment problem as Infrared model</a><ul><li class="level2"><a href="#autotoc_md178">The types of constraints and functions</a></li>
<li class="level2"><a href="#autotoc_md179">Setting up the model</a></li>
<li class="level2"><a href="#autotoc_md180">Performing optimization to compute an optimal alignment</a></li>
<li class="level2"><a href="#autotoc_md181">Sampling alignments</a><ul><li class="level3"><a href="#autotoc_md182">Optimzing over sampled alignments</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md183">Stacking extension</a></li>
</ul>
</div>
<div class="textblock"><hr  />
<h1><a class="anchor" id="autotoc_md169"></a>
Online resources and software environment</h1>
<p >​</p>
<p >This document is hosted online as <a href="https://www.lix.polytechnique.fr/~will/Software/Infrared/current/Doc/Alignment.ipynb">Jupyter notebook</a> with precomputed results. Download this file to view, edit and run examples in Jupyter.</p>
<p >​</p>
<p >We recommend to install all required software using Mamba (or Conda) and PIP.</p>
<div class="fragment"><div class="line">mamba create -n infrared -c conda-forge infrared jupyter jupytext matplotlib seaborn graphviz</div>
<div class="line"> </div>
<div class="line">mamba activate infrared</div>
<div class="line"> </div>
<div class="line">pip install graphviz</div>
<div class="line"> </div>
<div class="line">mamba deactivate infrared</div>
</div><!-- fragment --><p >​</p>
<p >Start the Jupyter notebook server after activating the environment</p>
<div class="fragment"><div class="line">mamba activate infrared</div>
<div class="line"> </div>
<div class="line">jupyter notebook</div>
</div><!-- fragment --><p >The <a href="https://gitlab.inria.fr/amibio/Infrared/-/tree/master/Doc/Examples">original sources</a> are part of the Infrared distribution and hosted on Gitlab (in Jupytext light Script format).</p>
<p >​</p>
<hr  />
<h1><a class="anchor" id="autotoc_md171"></a>
The alignment problem</h1>
<p >We demonstrate LicoRNA-style alignment in Infrared. The code models and solves a variant of the pairwise RNA structure alignment where a potentially crossing secondary structure is given for the first sequence; it is aligned against the 'plain' second sequence. The alignment score captures correlated matches to the ends of base pairs. The model furthermore supports affine gap cost.</p>
<p ><em>Definition:</em> RNA structure alignment 'CROSSING/PLAIN'. Given two sequences and a crossing structure of the first one, find the best pairwise alignment subject to the alignment score, consisting of</p><ul>
<li>position dependent base similarity</li>
<li>affine gap cost</li>
<li>similarity of base pair matches, depending on the base pair and the positions in the second sequence that are matched to the base pair ends</li>
</ul>
<p ><em>Note</em>: The standard CTE evaluation by Infrared does not handle "smooth bags" optimally. Since we compute banded alignments, this multiplies run-time by the banding width.</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> infrared <span class="keyword">as</span> ir</div>
<div class="line"><span class="keyword">import</span> infrared.rna <span class="keyword">as</span> rna</div>
<div class="line"><span class="keyword">import</span> treedecomp</div>
<div class="line"> </div>
<div class="line"><span class="keyword">import</span> math</div>
<div class="line"><span class="keyword">import</span> time</div>
<div class="line"><span class="keyword">import</span> RNA</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md172"></a>
Problem input and test instances</h1>
<p >We define several test instances. Each one is specified by two sequences \(a\) and \(b\) and a structure \(s\) for \(a\). The structure can be crossing! It is specified in extended dot-bracket notation.</p>
<div class="fragment"><div class="line"><span class="comment"># a small test instance</span></div>
<div class="line">ex_small = dict(\</div>
<div class="line">    a = <span class="stringliteral">&quot;ACGGUC&quot;</span>,</div>
<div class="line">    s = <span class="stringliteral">&quot;(([))]&quot;</span>,</div>
<div class="line">    b = <span class="stringliteral">&quot;UUGCAG&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># another small test instance</span></div>
<div class="line">ex_small2 = dict(\</div>
<div class="line">    a = <span class="stringliteral">&quot;AAAACAUAG&quot;</span>,</div>
<div class="line">    s = <span class="stringliteral">&quot;..(.[.).]&quot;</span>,</div>
<div class="line">    b = <span class="stringliteral">&quot;AGAUACUAU&quot;</span>)</div>
<div class="line"> </div>
<div class="line">ex_small3 = dict(\</div>
<div class="line">    a = <span class="stringliteral">&quot;AAAACAGAUAGAC&quot;</span>,</div>
<div class="line">    s = <span class="stringliteral">&quot;..(.[.{.).].}&quot;</span>,</div>
<div class="line">    b = <span class="stringliteral">&quot;AGAUACAGAAAC&quot;</span>)</div>
<div class="line"> </div>
<div class="line">ex_simple_crossing = dict(\</div>
<div class="line">    a = <span class="stringliteral">&quot;CGCCAAUACAAUAGGGUUUAU&quot;</span>,</div>
<div class="line">    s = <span class="stringliteral">&quot;(.((.[[[.....)))..]]]&quot;</span>,</div>
<div class="line">    b = <span class="stringliteral">&quot;GCGCAAACAAGCGAAUUUUAA&quot;</span>)</div>
<div class="line"> </div>
<div class="line">ex_simple_crossing2 = dict(\</div>
<div class="line">    a = <span class="stringliteral">&quot;GGCGCCAAUAUCCAAUAGGGUCCUGGUAU&quot;</span>,</div>
<div class="line">    s = <span class="stringliteral">&quot;(((.((.[[[[[.....)))))..]]]]]&quot;</span>,</div>
<div class="line">    b = <span class="stringliteral">&quot;GGCCCAUAUUCAAAUAAGGGACCUGGUCAU&quot;</span>)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">ex_intermediate = dict(\</div>
<div class="line">    a = <span class="stringliteral">&quot;CGCCAAUAAUAGGGUUUAU&quot;</span>,</div>
<div class="line">    s = <span class="stringliteral">&quot;(.(([[.[{{.)))]]]}}&quot;</span>,</div>
<div class="line">    b = <span class="stringliteral">&quot;GCGCAAACAAGCGAAUUUUU&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Licorna example RF01099 ( Treewidth 3 / 7 )</span></div>
<div class="line">ex_licorna_RF01099 = dict(\</div>
<div class="line">    a = <span class="stringliteral">&quot;UUCCAGGACAUACUGCUGAGGAUGUCAAAAAUGCAGUUGGAGUCCUCA&quot;</span>,</div>
<div class="line">    s = <span class="stringliteral">&quot;.&lt;&lt;&lt;&lt;&lt;...........((((((.............&gt;&gt;&gt;&gt;&gt;)))))).&quot;</span>,</div>
<div class="line">    b = <span class="stringliteral">&quot;UUCCAGGACAUACUGAUGAGAAUGUCAAAGAUGCAGUUGGGGUCCUCA&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Licorna example RF01831 ( Treewidth 4 / 9 )</span></div>
<div class="line">ex_licorna_RF01831 = dict(\</div>
<div class="line">    a = <span class="stringliteral">&quot;UCAGAGUAGAAAACGAUGCGUUAAGUGUCCAGCAGACGGGGAGUUGCUGCCGGAACGAAAAGCAAAGCUUGCGGUAUCGUUUUCGCAUCCCGCUGA&quot;</span>,</div>
<div class="line">    s = <span class="stringliteral">&quot;&lt;&lt;&lt;&lt;....&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;.....&lt;&lt;.&lt;&lt;&lt;.&lt;&lt;&lt;&lt;...(((.((..&gt;&gt;&gt;&gt;.&gt;&gt;&gt;&gt;&gt;...&lt;&lt;&lt;&lt;...&gt;&gt;&gt;&gt;...&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;)).)))..&gt;&gt;&gt;&gt;&quot;</span>,</div>
<div class="line">    b = <span class="stringliteral">&quot;GCAGAGUAGACACAUGUGCGUUAAGUGCCGGAUGAACAGGGAGUUGUCACCCGGACGAAAAGAAAAUCUUGCGGUACAUGAGUCGCAUCCCGCUGC&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Licorna example RF01786 (challenging b/c this requires large c)</span></div>
<div class="line">ex_licorna_RF01786 = dict(\</div>
<div class="line">    <span class="comment">#3Q3Z.seq vs target 2</span></div>
<div class="line">    a = <span class="stringliteral">&quot;CCCCGGAAACAAAAACGAAUGUGAAUGGGUUGGGCAUGGGCACUAGACUCAUUUUGUGUUGCAAGUGCACCCGA&quot;</span>,</div>
<div class="line">    s = <span class="stringliteral">&quot;............((((.....((((((((((.....&lt;[[[[[[[.))))))))))..)))...]]]]]&gt;.]].)&quot;</span>,</div>
<div class="line">    b = <span class="stringliteral">&quot;ACUGCAAUGGGUGUGAUGAAGUCCGGACAGUAAUGUGGGCACUUAGUCCGGACCGAGCAAGUAGUGCAACCGACCAGAUGCAAA&quot;</span>)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md173"></a>
Specialized tree decomposition</h1>
<p ><b>Note</b>: this section is not directly part of modeling alignments, we introduce experimental functionality that will likely become part of he Infrared library.</p>
<p >Different tree decomopositions of the same tree width can result in practically relevant performance differences of Infrared's evaluation. This is even true when all variables have the same domain size, but it becomes even more critical, when variables have strongly different sizes (e.g. some variables are boolean, while the size of others is linear in the problem input).</p>
<p >NXOptDspTDFactory implements a heuristic form of tree decomposition that chooses the td with minimal product of domain sizes from a series of tree decompositions, which are heuristically produced to minimize tree width. In the case of equal domain sizes, the objective minimal tree width and minimal sum over domain size product is an adequate estimator of the run-time of the evaluation by CTE. In the case of strongly different domain sizes, there is generally no guarantee that the optimal sum of domain size products is achieved for minimal treewidth. (In practice, the proposed strategy is still preferable over standard tree decomposition.)</p>
<p >We try to adapt the search time to the problem complexity; in order to safe over-all computation time, it pays off to optimize harder for harder instances.</p>
<p >This code should be generalized and moved into the tree decomposition module.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>NXOptDspTDFactory(treedecomp.NXTreeDecompositionFactory):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">    Treedecomp factory that optimizes the sum of domain size products over </span></div>
<div class="line"><span class="stringliteral">    tree decompositions generated by NXTreeDecompositionFactory</span></div>
<div class="line"><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">    </span></div>
<div class="line"><span class="stringliteral">    </span><span class="keyword">def </span>__init__(self, model, verbose = False):</div>
<div class="line">        super().__init__(iterations=1, adaptive=<span class="keywordtype">None</span>)</div>
<div class="line"> </div>
<div class="line">        self._model = model</div>
<div class="line">        self._optdsp_verbose = verbose</div>
<div class="line">        </div>
<div class="line">    <span class="keyword">def </span>create(self, size, dependencies):        </div>
<div class="line">        </div>
<div class="line">        best_domsizeprod = <span class="keywordtype">None</span></div>
<div class="line"> </div>
<div class="line">        i=0</div>
<div class="line">        <span class="keywordflow">while</span> <span class="keyword">True</span>:</div>
<div class="line">            i+=1</div>
<div class="line">            </div>
<div class="line">            td = super().create(size, dependencies)</div>
<div class="line">            tw = td.treewidth()</div>
<div class="line">            </div>
<div class="line">            bags = td.get_bags()</div>
<div class="line">            </div>
<div class="line">            <span class="keyword">import</span> math</div>
<div class="line">            domsizeprod = sum(math.prod( self._model.domains[x].size() <span class="keywordflow">for</span> x <span class="keywordflow">in</span> bag ) <span class="keywordflow">for</span> bag <span class="keywordflow">in</span> bags)</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> best_domsizeprod==<span class="keywordtype">None</span> <span class="keywordflow">or</span> domsizeprod &lt; best_domsizeprod:</div>
<div class="line">                best_domsizeprod = domsizeprod</div>
<div class="line">                best_td = td</div>
<div class="line"> </div>
<div class="line">                </div>
<div class="line">                thresh = 33 * 1.5**(domsizeprod/3e8)</div>
<div class="line">                <span class="comment">#print(&#39;Thresh&#39;,thresh)</span></div>
<div class="line">            <span class="keywordflow">if</span> i &gt; thresh:</div>
<div class="line">                <span class="keywordflow">break</span></div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> self._optdsp_verbose:</div>
<div class="line">            print( <span class="stringliteral">&quot;After iteration&quot;</span>,i,<span class="stringliteral">&quot;: Treewidth:&quot;</span>,tw,end=<span class="stringliteral">&quot;, &quot;</span>)</div>
<div class="line">            <span class="comment">#print( &quot;Effective Treewidth:&quot;, max(len( [ x for x in b if x &lt;= len(a)+1 ]) for b in bags) -1, end=&quot;, &quot; )</span></div>
<div class="line">            print( f<span class="stringliteral">&quot;Domain size product sum: {best_domsizeprod:.2e}&quot;</span> )</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> best_td</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ConstTDFactory:</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;TD factory returning a constant TD</span></div>
<div class="line"><span class="stringliteral">    Allows to </span><span class="keywordflow">pass</span> <span class="keywordflow">and</span> reuse an already computed TD </div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">    </span><span class="keyword">def </span>__init__(self,td):</div>
<div class="line">        self._td = td</div>
<div class="line">    <span class="keyword">def </span>create(self,_size,_dependencies):</div>
<div class="line">        <span class="keywordflow">return</span> self._td</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md174"></a>
Showing information on the tree decomposition</h1>
<p ><b>Note</b>: this section is not an essential part of modeling alignments. It is included for demonstration purposes. We also introduce some experimental functionality that will likely become part of he Infrared library.</p>
<p >Code to display 'internal' information on the generated td for demonstration purposes.</p>
<p >Note: the function performs a Monkey patch on TreeDecomposition. This code should be generalized and moved to treedecomp</p>
<div class="fragment"><div class="line"><span class="keyword">def </span>show_td_info(engine,width=600):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">    Show information on tree decomposition</span></div>
<div class="line"><span class="stringliteral">    Args:</span></div>
<div class="line"><span class="stringliteral">      engine An Infrared engine (Optimizer, Sampler, ...)</span></div>
<div class="line"><span class="stringliteral">      width width of td plot</span></div>
<div class="line"><span class="stringliteral">    </span></div>
<div class="line"><span class="stringliteral">    Draws the tree decomposition </span><span class="keywordflow">and</span> prints some information (tree width, bag sizes...)</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">    </span></div>
<div class="line"><span class="stringliteral">    td = engine.td</span></div>
<div class="line"><span class="stringliteral">    model=engine._model</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">    index_to_namedvar=[]</span></div>
<div class="line"><span class="stringliteral">    varnames = list(model._domains.keys())</span></div>
<div class="line"><span class="stringliteral">    </span><span class="keywordflow">for</span> name <span class="keywordflow">in</span> varnames:</div>
<div class="line">        num = model.num_named_variables(name)</div>
<div class="line">        <span class="keywordflow">for</span> idx <span class="keywordflow">in</span> range(num):</div>
<div class="line">            index_to_namedvar.append( f<span class="stringliteral">&quot;{name}{idx}&quot;</span> )</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># Monkey patch TreeDecomposition.writeTD</span></div>
<div class="line">    <span class="keyword">from</span> treedecomp <span class="keyword">import</span> TreeDecomposition</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Write tree decomposition in dot format</span></div>
<div class="line">    <span class="comment"># Args: out output file handle</span></div>
<div class="line">    <span class="keyword">def </span>writeTD(self, out):</div>
<div class="line">        <span class="keyword">from</span> math <span class="keyword">import</span> sqrt, ceil</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">def </span>baglabel(bag):</div>
<div class="line">            <span class="keywordflow">if</span> len(bag) == 0:</div>
<div class="line">                <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span></div>
<div class="line"> </div>
<div class="line">            lwidth = ceil(sqrt(len(bag)))</div>
<div class="line">            lnum = ceil(len(bag) / lwidth)</div>
<div class="line">            xs = [index_to_namedvar[i] <span class="keywordflow">for</span> i <span class="keywordflow">in</span> sorted(bag)]</div>
<div class="line">            lines = list()</div>
<div class="line">            <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(0, lnum):</div>
<div class="line">                lines.append(<span class="stringliteral">&quot; &quot;</span>.join(xs[i*lwidth:(i+1)*lwidth]))</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;\\n&quot;</span>.join(lines)</div>
<div class="line"> </div>
<div class="line">        out.write(<span class="stringliteral">&quot;digraph G {\n\n&quot;</span>)</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> bagid, bag <span class="keywordflow">in</span> enumerate(self._bags):</div>
<div class="line">            label = baglabel(bag)</div>
<div class="line">            out.write(<span class="stringliteral">&quot;\tbag{} [label=\&quot;{}\&quot;]\n&quot;</span>.format(bagid+1, label))</div>
<div class="line"> </div>
<div class="line">        out.write(<span class="stringliteral">&quot;\n\n&quot;</span>)</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (x, y) <span class="keywordflow">in</span> self._edges:</div>
<div class="line">            edgelabel = <span class="stringliteral">&quot; &quot;</span>.join(</div>
<div class="line">                [index_to_namedvar[x] <span class="keywordflow">for</span> x <span class="keywordflow">in</span> self.diff_set(self._bags[x], self._bags[y])])</div>
<div class="line">            out.write(</div>
<div class="line">                <span class="stringliteral">&quot;\tbag{} -&gt; bag{}  [label=\&quot;{}\&quot;]\n&quot;</span>.format(x+1, y+1,</div>
<div class="line">                                                            edgelabel))</div>
<div class="line"> </div>
<div class="line">        out.write(<span class="stringliteral">&quot;\n}\n&quot;</span>)</div>
<div class="line"> </div>
<div class="line">    orig_writeTD = TreeDecomposition.writeTD</div>
<div class="line"> </div>
<div class="line">    TreeDecomposition.writeTD = writeTD</div>
<div class="line">    </div>
<div class="line">    print(<span class="stringliteral">&quot;tree width =&quot;</span>, td.treewidth())</div>
<div class="line">    </div>
<div class="line">    bags_w_names = [[ index_to_namedvar[x] <span class="keywordflow">for</span> x <span class="keywordflow">in</span> bag] <span class="keywordflow">for</span> bag <span class="keywordflow">in</span> td.bags]</div>
<div class="line">    </div>
<div class="line">    <span class="comment">#print(&quot;bags =&quot;, bags_w_names)</span></div>
<div class="line">    <span class="comment">#print(&quot;edges =&quot;, td.edges)</span></div>
<div class="line">    </div>
<div class="line">    tmpfile=<span class="stringliteral">&quot;tmp_out.png&quot;</span></div>
<div class="line">    engine.plot_td(tmpfile,<span class="stringliteral">&#39;png&#39;</span>)</div>
<div class="line">    </div>
<div class="line">    TreeDecomposition.writeTD = orig_writeTD</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">from</span> IPython.display <span class="keyword">import</span> Image</div>
<div class="line">    <span class="keywordflow">return</span> Image(filename=tmpfile,width=width)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md175"></a>
Represent alignments as objects</h1>
<p >As preparation, defining classes for representing alignments. This class is introduced for working with alignments in Infrared more conveniently. (For example, it translates from the internal representation of alignments to a more human-readable form.)</p>
<div class="fragment"><div class="line"><span class="keyword">def </span>is_compl(x,y):</div>
<div class="line">    <span class="keywordflow">return</span> (x+y) <span class="keywordflow">in</span> [<span class="stringliteral">&quot;AU&quot;</span>,<span class="stringliteral">&quot;CG&quot;</span>,<span class="stringliteral">&quot;GC&quot;</span>,<span class="stringliteral">&quot;GU&quot;</span>,<span class="stringliteral">&quot;UA&quot;</span>, <span class="stringliteral">&quot;UG&quot;</span>]</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Alignment:</div>
<div class="line">    <span class="keyword">def </span>__init__( self, assignment, a, s, b ):</div>
<div class="line">        self._a = a</div>
<div class="line">        self._s = s</div>
<div class="line">        self._b = b</div>
<div class="line">        self._assignment = assignment</div>
<div class="line">        self._values = assignment.values()</div>
<div class="line">        self._edges = self._values_to_edges(self.values[:len(a)+2])</div>
<div class="line">    </div>
<div class="line">    @ property</div>
<div class="line">    <span class="keyword">def </span>values(self):</div>
<div class="line">        <span class="keywordflow">return</span> self._values</div>
<div class="line"> </div>
<div class="line">    @ property</div>
<div class="line">    <span class="keyword">def </span>edges(self):</div>
<div class="line">        <span class="keywordflow">return</span> self._edges</div>
<div class="line"> </div>
<div class="line">    @ staticmethod </div>
<div class="line">    <span class="keyword">def </span>_values_to_edges(values):</div>
<div class="line">        edges = list()</div>
<div class="line">        <span class="keywordflow">for</span> x,x1 <span class="keywordflow">in</span> zip(values,values[1:]):</div>
<div class="line">            edges.append(x1-1 <span class="keywordflow">if</span> x&lt;x1 <span class="keywordflow">else</span> -1)</div>
<div class="line">        edges = edges[:-1]</div>
<div class="line">        <span class="keywordflow">return</span> (edges)</div>
<div class="line">    </div>
<div class="line">    @ property</div>
<div class="line">    <span class="keyword">def </span>induced_structure(self):</div>
<div class="line">        <span class="keywordflow">return</span> self._alignment_strings()[3].replace(<span class="stringliteral">&quot;-&quot;</span>,<span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>_alignment_strings(self):</div>
<div class="line">        s = list()</div>
<div class="line">        b = list()</div>
<div class="line">        a = list()</div>
<div class="line">        t = list()</div>
<div class="line">         </div>
<div class="line">        <span class="keywordflow">for</span> i,(x,x1) <span class="keywordflow">in</span> enumerate(zip(self._values,self._values[1:])):</div>
<div class="line">            <span class="keywordflow">if</span> x&lt;x1:</div>
<div class="line">                <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(x,x1-1):</div>
<div class="line">                    a.append(<span class="stringliteral">&#39;-&#39;</span>)</div>
<div class="line">                    s.append(<span class="stringliteral">&#39;-&#39;</span>)</div>
<div class="line">                    b.append(self._b[j])</div>
<div class="line">                <span class="keywordflow">if</span> i&lt;len(self._a):</div>
<div class="line">                    a.append(self._a[i])</div>
<div class="line">                    s.append(self._s[i])</div>
<div class="line">                    b.append(self._b[x1-1])</div>
<div class="line">            <span class="keywordflow">if</span> x==x1:</div>
<div class="line">                <span class="keywordflow">if</span> i&lt;len(self._a):</div>
<div class="line">                    a.append(self._a[i])</div>
<div class="line">                    s.append(self._s[i])</div>
<div class="line">                    b.append(<span class="stringliteral">&#39;-&#39;</span>)</div>
<div class="line"> </div>
<div class="line">        t = [ <span class="stringliteral">&#39;-&#39;</span> <span class="keywordflow">if</span> x==<span class="stringliteral">&#39;-&#39;</span> <span class="keywordflow">else</span> <span class="stringliteral">&#39;.&#39;</span> <span class="keywordflow">for</span> x <span class="keywordflow">in</span> b ]</div>
<div class="line">        s = <span class="stringliteral">&quot;&quot;</span>.join(s)</div>
<div class="line">        <span class="keywordflow">for</span> (i,j) <span class="keywordflow">in</span> rna.parse(s):</div>
<div class="line">            <span class="keywordflow">if</span> is_compl(b[i],b[j]):</div>
<div class="line">                t[i]=s[i]</div>
<div class="line">                t[j]=s[j]</div>
<div class="line">                    </div>
<div class="line">        <span class="keywordflow">return</span> [ s, <span class="stringliteral">&quot;&quot;</span>.join(a), <span class="stringliteral">&quot;&quot;</span>.join(b), <span class="stringliteral">&quot;&quot;</span>.join(t)]</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>__str__(self):</div>
<div class="line">        alignment = self._alignment_strings()</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;\n&quot;</span>.join(alignment)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md176"></a>
... and define the scoring scheme in a class</h2>
<p >This class encapsulates the scoring scheme, such that scoring paramter changes can be made at this centralized place.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>AliScore():</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Define the alignment score&quot;&quot;&quot;</span></div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>__init__(self, a, b):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">        Construct </span><span class="keyword">with</span> a pair of sequences</div>
<div class="line">        Args: </div>
<div class="line">          a first sequence string</div>
<div class="line">          b second sequence string</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">        self._a = a</span></div>
<div class="line"><span class="stringliteral">        self._b = b</span></div>
<div class="line"><span class="stringliteral">    </span><span class="keyword">def </span>beta( self ):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Gap opening cost&quot;&quot;&quot;</span></div>
<div class="line">        <span class="keywordflow">return</span> -3</div>
<div class="line">    <span class="keyword">def </span>gamma( self, k = 1 ):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">        Gap cost</span></div>
<div class="line"><span class="stringliteral">        Args:</span></div>
<div class="line"><span class="stringliteral">          k gap length</span></div>
<div class="line"><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">        </span><span class="keywordflow">return</span> -1 + self.beta()*k</div>
<div class="line">    <span class="keyword">def </span>sigma( self, x, y ):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">        Base similarity</span></div>
<div class="line"><span class="stringliteral">        Args:</span></div>
<div class="line"><span class="stringliteral">          x 1-based position </span><span class="keywordflow">in</span> first sequence</div>
<div class="line">          y 1-based position <span class="keywordflow">in</span> second sequence</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">        </span><span class="keywordflow">return</span> 2 <span class="keywordflow">if</span> self._a[x-1]==self._b[y-1] <span class="keywordflow">else</span> 0</div>
<div class="line">    <span class="keyword">def </span>psi( self, x, y ):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">        Base pair similarity</span></div>
<div class="line"><span class="stringliteral">        Args:</span></div>
<div class="line"><span class="stringliteral">          x match of left end, 1-based position </span><span class="keywordflow">in</span> second sequence</div>
<div class="line">          y match of right end, 1-based position <span class="keywordflow">in</span> second sequence</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;        </span></div>
<div class="line"><span class="stringliteral">        </span><span class="keywordflow">return</span> 10 <span class="keywordflow">if</span> is_compl(self._b[x-1],self._b[y-1]) <span class="keywordflow">else</span> 0</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md177"></a>
Expressing the alignment problem as Infrared model</h1>
<p >We implement the alignment model found in CTE-Alignment [1] and LicoRNA [2].</p>
<p >Given two input sequences a and b (words over an alphabet \(\Sigma\)) of resp. length \(n\) and \(m\), an <em>alignment</em> \(\cal A\) of \(a\) and \(b\) is a set of <em>alignment edges</em> \((i,j)\) with the properties</p>
<ul>
<li>the edges define a partial mapping between the positions in \(a\) and \(b\), \(1\leq i\leq n\), \(1\leq i\leq m\)</li>
<li><em>non-crossing</em>: for every pair of edges \((i_1,j_1)\), \((i_2,j_2)\) in \(\cal A\), \(i_1&lt;i_2 \Rightarrow j_1&lt;,j_2\).</li>
</ul>
<p >Alignments are evaluated by a score with affine gap cost, we define \(\textrm{aliscore}(\cal A) = \sum_{(i,j)\in\cal A} \sigma(i,j) + \sum_{\text{gaps }g\text{ in }\cal A} \gamma(|g|).\)</p>
<p >Here a gap in \(\cal A\), either deletion or insertion, consists of a maximal range of consecutive positions in \(a\) or \(b\) that are unmapped by \(\cal A\); it's length \(|g|\) is the number of unmapped positions. <br  />
</p>
<p >In extension of aliscore, we evaluate structure matches. Given a secondary structure \(R\) for \(a\), i.e. a set of base pairs, the function \(\phi\) scores the match of each base pair \((i,j)\in R\) ( \(1\leq i&lt;j&lt;\leq n\)) where \(i\) and \(j\) are matched to respective positions \(i&#39;\) and \(j&#39;\) by \(\phi(i,j,i&#39;,j&#39;)\). (Note that we can easily extend that to scoring arc breaks and alterings, where one or both ends are deleted, but keep it simple here).</p>
<p >Given \(a\), \(s\), and \(b\), the (structure) alignment is modeled as Infrared feature network, which defines the set of valid alignments as well as the score. It consists of</p>
<ul>
<li>variables \(X_0, \dots, X_{n+1}\) and variables \(Y_0,\dots,Y_n\)</li>
<li>the variables \(X_i\) have domains \(0..(m+1)\) (which will be further restricted); the variables \(Y_i\) have domains \(\{0,1\}\).</li>
<li>constraints \(X_0=0\), \(X_{n+1}={m+1}\), \(Y_0=1\)</li>
<li>constraints that impose \(X_i\leq X_i+1\) (for all \(0\leq i\leq n+1\))</li>
<li>constraints expressing \(Y_i=1\) iff \(X_{i-1}&lt;X_{i}\) (with the interpretation that \(Y_i==1\) iff \(i\) is matched to the value of \(X_i\))</li>
<li>functions that define the score</li>
</ul>
<p >Valid assignments to the variables have an interpretation as alignments. For example,</p>
<div class="fragment"><div class="line">A-AGAU</div>
<div class="line">AGA--U</div>
</div><!-- fragment --><p >i.e. the alignment \(\{(1,1),(2,3),(5,4)\}\) of the sequences AAGAU and AGAU ( \(n=5\), \(m=4\)) is encoded by</p>
<p >\(X_0=0, X_1=1, X_2=3, X_3=3, X_4=3, X_5=4, X_6=5\). The values of Y-variables are implied as \(Y_0=1, Y_1=1, Y_2=1, Y_3=0, Y_4=0, Y_5=1\).</p>
<p >[1] Sebastian Will, Anke Busch &amp; Rolf Backofen. Efficient Sequence Alignment with Side-Constraints by Cluster Tree Elimination, Constraints, 2008.</p>
<p >[2] Philippe Rinaudo, Yann Ponty, Dominique Barth &amp; Alain Denise. Tree Decomposition and Parameterized Algorithms for RNA Structure-Sequence Alignment Including Tertiary Interactions and Pseudoknots, Proc of WABI, 2012.</p>
<h2><a class="anchor" id="autotoc_md178"></a>
The types of constraints and functions</h2>
<p >We define specialized constraints and functions to define the alignment model for a specific instance. Constraints are used to express order on the X variables. The functions are used to define the alignment score.</p>
<p >Note that the constraint and function class definitions use the Python function <code>var</code> to translate named variables to internal indices. In this way, we can distinguish variables like \(X_0,...X_n+1\) and \(Y_0,...Y_n+1\) and use this naming scheme in the code.</p>
<div class="fragment"><div class="line"><span class="comment"># express order and equality on variables</span></div>
<div class="line">ir.def_constraint_class( <span class="stringliteral">&#39;LeqConstraint&#39;</span>, <span class="keyword">lambda</span> i,var: var([(<span class="stringliteral">&#39;X&#39;</span>,i-1),(<span class="stringliteral">&#39;X&#39;</span>,i)]),</div>
<div class="line">                      <span class="keyword">lambda</span> x1,x: x1&lt;=x )</div>
<div class="line">ir.def_constraint_class( <span class="stringliteral">&#39;EqConstraint&#39;</span>, <span class="keyword">lambda</span> thevar,c,var: var([thevar]), <span class="keyword">lambda</span> x,c: x==c )</div>
<div class="line"> </div>
<div class="line"><span class="comment"># relate variables X and Y in the model</span></div>
<div class="line">ir.def_constraint_class( <span class="stringliteral">&#39;XYRelation&#39;</span>, <span class="keyword">lambda</span> i,var: var([(<span class="stringliteral">&#39;X&#39;</span>,i-1),(<span class="stringliteral">&#39;X&#39;</span>,i),(<span class="stringliteral">&#39;Y&#39;</span>,i)]),</div>
<div class="line">                      <span class="keyword">lambda</span> x1,x,y: (x1&lt;x <span class="keywordflow">and</span> y==1) <span class="keywordflow">or</span> (x1==x <span class="keywordflow">and</span> y==0) )</div>
<div class="line"> </div>
<div class="line"><span class="comment"># restrict domain sizes due to banding (superseeded by direct domain restriction; only left for demonstration)</span></div>
<div class="line">ir.def_constraint_class( <span class="stringliteral">&#39;BandingConstraint&#39;</span>, <span class="keyword">lambda</span> i,c,n,m,var: var([(<span class="stringliteral">&#39;X&#39;</span>,i)]),</div>
<div class="line">                      <span class="keyword">lambda</span> x,i,c,n,m: abs(x-i*m/n) &lt;= c )</div>
<div class="line"> </div>
<div class="line"><span class="comment"># similarity of positions in the two sequences.</span></div>
<div class="line">ir.def_function_class( <span class="stringliteral">&#39;SigmaFunction&#39;</span>, <span class="keyword">lambda</span> i,score,var: var([ (<span class="stringliteral">&#39;X&#39;</span>,i), (<span class="stringliteral">&#39;Y&#39;</span>,i) ]),</div>
<div class="line">                     <span class="keyword">lambda</span> x,y,i,score: score.sigma(i,x) <span class="keywordflow">if</span> y==1 <span class="keywordflow">else</span> 0 )</div>
<div class="line"> </div>
<div class="line"><span class="comment"># insertion of bases</span></div>
<div class="line">ir.def_function_class( <span class="stringliteral">&#39;InsertFunction&#39;</span>, <span class="keyword">lambda</span> i,score,var: var([(<span class="stringliteral">&#39;X&#39;</span>,i-1),(<span class="stringliteral">&#39;X&#39;</span>,i)]),</div>
<div class="line">                    <span class="keyword">lambda</span> x1,x,score: score.gamma(x-x1-1) <span class="keywordflow">if</span> x1+1&lt;x <span class="keywordflow">else</span> 0 )</div>
<div class="line"> </div>
<div class="line"><span class="comment"># deletion of bases</span></div>
<div class="line">ir.def_function_class( <span class="stringliteral">&#39;DeleteFunction&#39;</span>, <span class="keyword">lambda</span> i,score,var: var([(<span class="stringliteral">&#39;Y&#39;</span>,i-1),(<span class="stringliteral">&#39;Y&#39;</span>,i)]),</div>
<div class="line">                    <span class="keyword">lambda</span> y1,y,score: ( score.beta() <span class="keywordflow">if</span> y1==0 <span class="keywordflow">else</span> score.gamma(1) ) <span class="keywordflow">if</span> y==0 <span class="keywordflow">else</span> 0 )</div>
<div class="line"> </div>
<div class="line"><span class="comment"># matches at base pairs</span></div>
<div class="line">ir.def_function_class( <span class="stringliteral">&#39;PhiFunction&#39;</span>, <span class="keyword">lambda</span> i,j,score,var: var([(<span class="stringliteral">&#39;X&#39;</span>,i),(<span class="stringliteral">&#39;Y&#39;</span>,i),(<span class="stringliteral">&#39;X&#39;</span>,j),(<span class="stringliteral">&#39;Y&#39;</span>,j)]),</div>
<div class="line">                    <span class="keyword">lambda</span> xi,yi,xj,yj,score: score.psi(xi,xj) <span class="keywordflow">if</span> yi==1 <span class="keywordflow">and</span> yj==1 <span class="keywordflow">else</span> 0 )</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md179"></a>
Setting up the model</h2>
<p >First, we define the concrete problem instance, select control options and heuristic parameters.</p>
<div class="fragment"><div class="line"><span class="comment"># control whether to use banding by direct domain restriction (or constraint). The former is way more efficient.</span></div>
<div class="line">DOMAIN_BANDING = <span class="keyword">True</span></div>
<div class="line"><span class="comment">#DOMAIN_BANDING = False</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">#ex = ex_small2</span></div>
<div class="line">ex = ex_simple_crossing2</div>
<div class="line"><span class="comment">#ex = ex_intermediate</span></div>
<div class="line"><span class="comment">#ex = ex_licorna_RF01099</span></div>
<div class="line"><span class="comment">#ex = ex_licorna_RF01831</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># constant offset for banding</span></div>
<div class="line">c=4</div>
<div class="line"> </div>
<div class="line">print(ex[<span class="stringliteral">&#39;s&#39;</span>])</div>
<div class="line">print(ex[<span class="stringliteral">&#39;a&#39;</span>], len(ex[<span class="stringliteral">&#39;a&#39;</span>]))</div>
<div class="line">print(ex[<span class="stringliteral">&#39;b&#39;</span>], len(ex[<span class="stringliteral">&#39;b&#39;</span>]))</div>
</div><!-- fragment --> <pre class="fragment">(((.((.[[[[[.....)))))..]]]]]
GGCGCCAAUAUCCAAUAGGGUCCUGGUAU 29
GGCCCAUAUUCAAAUAAGGGACCUGGUCAU 30
</pre><div class="fragment"><div class="line"><span class="comment"># LicoRNA sets c to at least the length difference; this is skipped here</span></div>
<div class="line"><span class="comment"># c = max(c,abs(len(a)-len(b)))</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">#n = len(ex[&#39;a&#39;])</span></div>
<div class="line"><span class="comment">#m = len(ex[&#39;b&#39;])</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>alignment_model(a,s,b):</div>
<div class="line">    </div>
<div class="line">    n = len(a)</div>
<div class="line">    m = len(b)</div>
<div class="line">    bps = rna.parse(s)</div>
<div class="line">    score = AliScore(a,b)</div>
<div class="line"> </div>
<div class="line">    model = ir.Model()</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># X_i&#39;s encode alignments, such that </span></div>
<div class="line">    <span class="comment">#  * X_i=j for alignment edges (i,j) (1-based pos indices!) and</span></div>
<div class="line">    <span class="comment">#  * X_i==X_i-1 if X_i is deleted</span></div>
<div class="line">    <span class="comment">#  * X_0 = 0</span></div>
<div class="line">    <span class="comment">#  * X_n+1=m+1</span></div>
<div class="line">    model.add_variables( 1, (0,0), name = <span class="stringliteral">&#39;X&#39;</span> )</div>
<div class="line">    model.add_variables( n, (0,m), name = <span class="stringliteral">&#39;X&#39;</span> )</div>
<div class="line">    model.add_variables( 1, (m+1,m+1), name = <span class="stringliteral">&#39;X&#39;</span> )</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Y_i is 1 iff i is matched</span></div>
<div class="line">    model.add_variables( 1, (1,1), name = <span class="stringliteral">&#39;Y&#39;</span> )</div>
<div class="line">    model.add_variables( n, 2, name = <span class="stringliteral">&#39;Y&#39;</span> )</div>
<div class="line"> </div>
<div class="line">    var = model.idx</div>
<div class="line"> </div>
<div class="line">    model.add_constraints( LeqConstraint( i, var ) <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(1,n+2) )</div>
<div class="line">    model.add_constraints( XYRelation( i, var ) <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(1,n+1) )</div>
<div class="line"> </div>
<div class="line">    <span class="comment">#model.add_constraints( EqConstraint( (&#39;X&#39;,n+1), m+1, var ) )</span></div>
<div class="line">    <span class="comment">#model.add_constraints( EqConstraint( (&#39;Y&#39;,0), 1, var ) )</span></div>
<div class="line"> </div>
<div class="line">    model.restrict_domains( (<span class="stringliteral">&#39;Y&#39;</span>,1), (1,1) )</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> DOMAIN_BANDING:</div>
<div class="line">        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(1,n+1):</div>
<div class="line">            lb = max(1, math.floor(i*m/n) - c)</div>
<div class="line">            ub = min(m, math.ceil(i*m/n) + c )</div>
<div class="line">            model.restrict_domains( (<span class="stringliteral">&#39;X&#39;</span>,i), (lb,ub) )    </div>
<div class="line">    <span class="keywordflow">else</span>:</div>
<div class="line">        model.add_constraints( BandingConstraint( i, c, n, m, var ) <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(1,n+1) )</div>
<div class="line"> </div>
<div class="line">    model.add_functions( [ SigmaFunction( i, score, var )</div>
<div class="line">                           <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range( 1, n+1 ) ], group = <span class="stringliteral">&#39;sigma&#39;</span> )</div>
<div class="line">    model.add_functions( [ InsertFunction( i, score, var )</div>
<div class="line">                           <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range( 1, n+2 ) ], group = <span class="stringliteral">&#39;indels&#39;</span> )</div>
<div class="line">    model.add_functions( [ DeleteFunction( i, score, var )</div>
<div class="line">                           <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range( 1, n+1 ) ], group = <span class="stringliteral">&#39;indels&#39;</span>)</div>
<div class="line"> </div>
<div class="line">    model.add_functions( [ PhiFunction(i+1, j+1, score, var) <span class="keywordflow">for</span> (i,j) <span class="keywordflow">in</span> bps ], group = <span class="stringliteral">&#39;phi&#39;</span> )</div>
<div class="line"> </div>
<div class="line">    </div>
<div class="line">    w = 1</div>
<div class="line">    model.set_feature_weight(w,<span class="stringliteral">&quot;sigma&quot;</span>)</div>
<div class="line">    model.set_feature_weight(w,<span class="stringliteral">&quot;indels&quot;</span>)</div>
<div class="line">    model.set_feature_weight(w,<span class="stringliteral">&quot;phi&quot;</span>)</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> model</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md180"></a>
Performing optimization to compute an optimal alignment</h2>
<div class="fragment"><div class="line">model = alignment_model(ex[<span class="stringliteral">&#39;a&#39;</span>],ex[<span class="stringliteral">&#39;s&#39;</span>],ex[<span class="stringliteral">&#39;b&#39;</span>])</div>
<div class="line"> </div>
<div class="line">td_factory = NXOptDspTDFactory(model, verbose=<span class="keyword">True</span>)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">alioptimizer = ir.Optimizer( model, td_factory )</div>
<div class="line"> </div>
<div class="line">t0 = time.time()</div>
<div class="line"> </div>
<div class="line"><span class="comment">#print( &quot;Treewidth:&quot;, alioptimizer.treewidth())</span></div>
<div class="line">bags = alioptimizer.td.bags</div>
<div class="line">n = len(ex[<span class="stringliteral">&#39;a&#39;</span>])</div>
<div class="line">print( <span class="stringliteral">&quot;Effective Treewidth (on X_i):&quot;</span>, max(len( [ x <span class="keywordflow">for</span> x <span class="keywordflow">in</span> b <span class="keywordflow">if</span> x &lt;= n+1 ]) <span class="keywordflow">for</span> b <span class="keywordflow">in</span> bags) -1)</div>
<div class="line"> </div>
<div class="line">print(<span class="stringliteral">&quot;Banding:&quot;</span>, c)</div>
<div class="line"> </div>
<div class="line">alioptimizer.plot_td(<span class="stringliteral">&quot;treedecomp.pdf&quot;</span>)</div>
<div class="line">      </div>
<div class="line">print(f<span class="stringliteral">&quot;t = {time.time()-t0:.1f}s&quot;</span>)</div>
<div class="line"> </div>
<div class="line">best_score = round( alioptimizer.evaluate() )</div>
<div class="line">print(f<span class="stringliteral">&quot;Optimal alignment score: {best_score}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">best_alignment = alioptimizer.optimize()</div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>report_alignment(alignment):</div>
<div class="line">    sigma = model.eval_feature( alignment, <span class="stringliteral">&#39;sigma&#39;</span> )</div>
<div class="line">    indels = model.eval_feature( alignment, <span class="stringliteral">&#39;indels&#39;</span> )</div>
<div class="line">    phi = model.eval_feature( alignment, <span class="stringliteral">&#39;phi&#39;</span> )</div>
<div class="line">    print(f<span class="stringliteral">&quot;Score {sigma + indels + phi} = {sigma} + {indels} + {phi}&quot;</span> )</div>
<div class="line">    print( Alignment( alignment, ex[<span class="stringliteral">&#39;a&#39;</span>], ex[<span class="stringliteral">&#39;s&#39;</span>], ex[<span class="stringliteral">&#39;b&#39;</span>] ) )</div>
<div class="line">    print()</div>
<div class="line">    </div>
<div class="line">report_alignment(best_alignment)</div>
<div class="line">print(f<span class="stringliteral">&quot;t = {time.time()-t0:.1f}s&quot;</span>)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">print(<span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;----- TD Info -----&quot;</span>)</div>
<div class="line">show_td_info(alioptimizer,width=550)</div>
</div><!-- fragment --> <pre class="fragment">After iteration 34 : Treewidth: 7, Domain size product sum: 1.57e+06
Effective Treewidth (on X_i): 3
Banding: 4
t = 0.4s
Optimal alignment score: 120
Score 120 = 50 + -20 + 90
(((.((.[[[[[...-..-)))))..]]]-]]
GGCGCCAAUAUCCAA-UA-GGGUCCUGGU-AU
GGC-CC-AUAUUCAAAUAAGGGACCUGGUCAU
(.(-((-[[[[[.......))).)..]]].]]

t = 0.8s


----- TD Info -----
tree width = 7
</pre><p ><img src="Alignment_files/Alignment_20_1.png" alt="png" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md181"></a>
Sampling alignments</h2>
<div class="fragment"><div class="line"><span class="comment"># set weights (=&#39;inverse temperature&#39;)</span></div>
<div class="line">w = 0.5</div>
<div class="line">model.set_feature_weight(w,<span class="stringliteral">&quot;sigma&quot;</span>)</div>
<div class="line">model.set_feature_weight(w,<span class="stringliteral">&quot;indels&quot;</span>)</div>
<div class="line">model.set_feature_weight(w,<span class="stringliteral">&quot;phi&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># number of samples</span></div>
<div class="line">K=5</div>
<div class="line"> </div>
<div class="line"><span class="comment"># sampler for the model</span></div>
<div class="line">alisampler = ir.BoltzmannSampler( model, ConstTDFactory(alioptimizer.td) )</div>
<div class="line"> </div>
<div class="line">alisampler.setup_engine()</div>
<div class="line">pf = alisampler.ct.evaluate()</div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&quot;Partition function = {pf:.2e}&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># note, here we ignore degeneracy, i.e. multiple optimal solutions</span></div>
<div class="line">popt = math.exp(w*best_score)/pf</div>
<div class="line">print(f<span class="stringliteral">&quot;Probability of single optimum = { popt :.2f}&quot;</span>)</div>
<div class="line">print(f<span class="stringliteral">&quot;Pr to see this optimum in {K} samples = { 1-(1-popt)**K :.2f}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&quot;t = {time.time()-t0:.1f}s&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># and print samples</span></div>
<div class="line"><span class="keywordflow">for</span> _ <span class="keywordflow">in</span> range(K):</div>
<div class="line">    sample = alisampler.sample()</div>
<div class="line">    print()</div>
<div class="line">    report_alignment(sample)</div>
<div class="line">    </div>
<div class="line">print()</div>
<div class="line">print(f<span class="stringliteral">&quot;t = {time.time()-t0:.1f}s&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="keyword">import</span> os, psutil</div>
<div class="line">process = psutil.Process(os.getpid())</div>
<div class="line">print(f<span class="stringliteral">&#39;RSS {process.memory_info().rss/1024/1024:.1f} Mb&#39;</span>)  <span class="comment"># in bytes</span></div>
</div><!-- fragment --> <pre class="fragment">Partition function = 5.15e+27
Probability of single optimum = 0.02
Pr to see this optimum in 5 samples = 0.11
t = 1.7s

Score 120 = 48 + -28 + 100
(((.((.[[[[-[.....-)))-))..]]]-]]
GGCGCCAAUAU-CCAAUA-GGG-UCCUGGU-AU
GGC-CC-AUAUUCAAAUAAGGGACC-UGGUCAU
(((-((-[[[[.[......))).))-.]]].]]


Score 120 = 48 + -28 + 100
(((.((.[[[[-[.....-)))-))..]]]-]]
GGCGCCAAUAU-CCAAUA-GGG-UCCUGGU-AU
GGC-CC-AUAUUCAAAUAAGGGACC-UGGUCAU
(((-((-[[[[.[......))).))-.]]].]]


Score 82 = 44 + -42 + 80
(((.((.[[[-[[-.--....-)))))..]]]-]]
GGCGCCAAUA-UC-C--AAUA-GGGUCCUGGU-AU
GGC-CC-AUAUUCAAAUA--AGG-GACCUGGUCAU
(.(-.(-[[[.[[.....--..)-).)..]]].]]


Score 116 = 44 + -28 + 100
(((.((.[[[-[[...-..)))-))..]]]-]]
GGCGCCAAUA-UCCAA-UAGGG-UCCUGGU-AU
GGC-CC-AUAUUCAAAUAAGGGACCU-GGUCAU
(((-((-[[[.[[......))).)).-]]].]]


Score 118 = 46 + -28 + 100
(((.((.[[[[-[...-..)))-))..]]]-]]
GGCGCCAAUAU-CCAA-UAGGG-UCCUGGU-AU
GGC-CC-AUAUUCAAAUAAGGGACC-UGGUCAU
(((-((-[[[[.[......))).))-.]]].]]


t = 1.7s
RSS 109.8 Mb
</pre><h3><a class="anchor" id="autotoc_md182"></a>
Optimzing over sampled alignments</h3>
<div class="fragment"><div class="line"><span class="keyword">def </span>evaluate_alignment(sample, verbose=False, score_weight=1/2):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">    Evaluate assignments based on theromdynamic energy</span></div>
<div class="line"><span class="stringliteral">    of the induced structure </span><span class="keywordflow">in</span> the second sequence</div>
<div class="line">    <span class="keywordflow">and</span> the alignment score</div>
<div class="line">    </div>
<div class="line">    The energy <span class="keywordflow">is</span> defined <span class="keyword">as</span> sum over all interior loop energies.</div>
<div class="line">    </div>
<div class="line">    The score <span class="keywordflow">is</span> subtracted <span class="keyword">from</span> the energy <span class="keyword">with</span> a weighting factor.</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">        </span></div>
<div class="line"><span class="stringliteral">    alignment = Alignment( sample, ex[&#39;a&#39;</span>], ex[<span class="stringliteral">&#39;s&#39;</span>], ex[<span class="stringliteral">&#39;b&#39;</span>] )</div>
<div class="line">    edges = alignment.edges</div>
<div class="line">    bps = rna.parse(alignment.induced_structure)</div>
<div class="line">    </div>
<div class="line">    right_end = {i:j <span class="keywordflow">for</span> (i,j) <span class="keywordflow">in</span> bps}        </div>
<div class="line">    <span class="keyword">def </span>inner_basepair(i,j):</div>
<div class="line">        inner_basepair = <span class="keywordtype">None</span></div>
<div class="line">        k=i+1</div>
<div class="line">        <span class="keywordflow">while</span> k&lt;j:</div>
<div class="line">            <span class="keywordflow">if</span> k <span class="keywordflow">in</span> right_end:</div>
<div class="line">                l = right_end[k]</div>
<div class="line">                <span class="keywordflow">if</span> l&lt;j <span class="keywordflow">and</span> inner_basepair==<span class="keywordtype">None</span>:</div>
<div class="line">                        <span class="keywordflow">return</span> (k,l)</div>
<div class="line">                        k = l+1</div>
<div class="line">                        <span class="keywordflow">continue</span></div>
<div class="line">                <span class="keywordflow">else</span>:</div>
<div class="line">                    <span class="keywordflow">return</span> <span class="keywordtype">None</span></div>
<div class="line">            k+=1</div>
<div class="line">    </div>
<div class="line">    energy = 0</div>
<div class="line">    fc = RNA.fold_compound(ex[<span class="stringliteral">&#39;b&#39;</span>])</div>
<div class="line">    <span class="keywordflow">for</span> (i,j) <span class="keywordflow">in</span> bps:</div>
<div class="line">        kl = inner_basepair(i,j)</div>
<div class="line">        <span class="keywordflow">if</span> kl:</div>
<div class="line">            k,l = kl</div>
<div class="line">            loop_energy = fc.eval_int_loop(i+1,j+1,k+1,l+1)</div>
<div class="line">            energy += loop_energy</div>
<div class="line">            <span class="keywordflow">if</span> verbose:</div>
<div class="line">                print((i,j),(k,l),loop_energy)</div>
<div class="line">    <span class="keywordflow">return</span> energy - score_alignment(sample) * score_weight</div>
<div class="line">    </div>
<div class="line"><span class="keyword">def </span>score_alignment(alignment):</div>
<div class="line">    sigma = model.eval_feature( alignment, <span class="stringliteral">&#39;sigma&#39;</span> )</div>
<div class="line">    indels = model.eval_feature( alignment, <span class="stringliteral">&#39;indels&#39;</span> )</div>
<div class="line">    phi = model.eval_feature( alignment, <span class="stringliteral">&#39;phi&#39;</span> )</div>
<div class="line">    <span class="keywordflow">return</span> sigma + indels + phi</div>
<div class="line"> </div>
<div class="line"><span class="comment">#optimize to know the best alignment score</span></div>
<div class="line">best_score = alioptimizer.evaluate()</div>
<div class="line">best_alignment = alioptimizer.optimize()</div>
<div class="line">report_alignment(best_alignment)</div>
<div class="line">e = evaluate_alignment(best_alignment, <span class="keyword">True</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;Evaluation&quot;</span>,e)</div>
<div class="line">print()</div>
<div class="line"> </div>
<div class="line"><span class="comment">#sample at lower weight, such that the optimum is still generated</span></div>
<div class="line">w = 0.3</div>
<div class="line">model.set_feature_weight(w,<span class="stringliteral">&quot;sigma&quot;</span>)</div>
<div class="line">model.set_feature_weight(w,<span class="stringliteral">&quot;indels&quot;</span>)</div>
<div class="line">model.set_feature_weight(w,<span class="stringliteral">&quot;phi&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># sampler for the model</span></div>
<div class="line">alisampler = ir.BoltzmannSampler( model, ConstTDFactory(alioptimizer.td) )</div>
<div class="line"> </div>
<div class="line"><span class="comment"># generate samples, evaluate, and keep best</span></div>
<div class="line">K=5000</div>
<div class="line"> </div>
<div class="line">count_best = 0</div>
<div class="line">scores = list()</div>
<div class="line">evaluations = list()</div>
<div class="line">best_e = 1000</div>
<div class="line"><span class="keywordflow">for</span> _ <span class="keywordflow">in</span> range(K):</div>
<div class="line">    sample = alisampler.sample()</div>
<div class="line">    <span class="comment">#report_alignment(sample)</span></div>
<div class="line">    score = score_alignment(sample)</div>
<div class="line">    scores.append(score)</div>
<div class="line">    count_best += score ==  best_score</div>
<div class="line">    e = evaluate_alignment(sample)</div>
<div class="line">    evaluations.append(e)</div>
<div class="line">    <span class="keywordflow">if</span> best_e &gt; e:</div>
<div class="line">        best_e = e</div>
<div class="line">        best_e_alignment = sample</div>
<div class="line">    </div>
<div class="line">print()</div>
<div class="line">print(f<span class="stringliteral">&quot;Frequency of optimal score: {count_best/K*100:.2f}%&quot;</span>)</div>
<div class="line">print()</div>
<div class="line"> </div>
<div class="line">report_alignment(best_e_alignment)</div>
<div class="line">evaluate_alignment(best_e_alignment,<span class="keyword">True</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;Best evaluation&quot;</span>,best_e)</div>
<div class="line">print()</div>
</div><!-- fragment --> <pre class="fragment">Score 120 = 50 + -20 + 90
(((.((.[[[[[...-..-)))))..]]]-]]
GGCGCCAAUAUCCAA-UA-GGGUCCUGGU-AU
GGC-CC-AUAUUCAAAUAAGGGACCUGGUCAU
(.(-((-[[[[[.......))).)..]]].]]

(0, 21) (2, 19) 50
(2, 19) (3, 18) -330
(3, 18) (4, 17) -330
(5, 29) (6, 28) -110
(6, 28) (7, 26) 250
(7, 26) (8, 25) -140
(8, 25) (9, 24) -50
Evaluation -720.0


Frequency of optimal score: 7.70%

Score 94 = 42 + -28 + 80
(((.((.[[[[[.-..-..)))-))..]]]]]-
GGCGCCAAUAUCC-AA-UAGGG-UCCUGGUAU-
GGC-CCA-UAUUCAAAUAAGGGACC-UGGUCAU
(((-((.-.[[[.......))).))-.]]]...

(0, 22) (1, 21) -330
(1, 21) (2, 19) 40
(2, 19) (3, 18) -330
(3, 18) (4, 17) -330
(7, 26) (8, 25) -140
(8, 25) (9, 24) -50
Best evaluation -1187.0
</pre><div class="fragment"><div class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</div>
<div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div>
<div class="line">sns.jointplot(x=scores,y=evaluations)</div>
<div class="line">plt.xlabel(<span class="stringliteral">&quot;Alignment score&quot;</span>)</div>
<div class="line">plt.ylabel(<span class="stringliteral">&quot;Energy evaluation&quot;</span>)</div>
<div class="line">plt.show()</div>
</div><!-- fragment --><p ><img src="Alignment_files/Alignment_25_0.png" alt="png" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md183"></a>
Stacking extension</h1>
<p >To extend the alignment score with stacking terms, introduce boolean variables</p><ul>
<li>\(ZC_i\) (1&lt;=i&lt;=n) for "consecutive match", \(Z_i\) indicates that positions i-1 and i are both matched and are matched to consecutive positions</li>
<li>\(ZM_k\) for each base pair with index \(k\). \(ZM_k\) indicates that the base pair is matched to complementary bases</li>
</ul>
<p >Two series of constraints respectively relate the variables \(X\), \(Y\) and \(ZC\) as well as the variables \(X\), \(Y\), and \(ZM\).</p>
<p >Finally, we introduce functions 'Stacking' to score the stacks; these functions depend on the new variables \(ZC\) and \(ZM\) to detect consecutive, complementary matched base pairs.</p>
<div class="fragment"><div class="line"><span class="comment"># Constraint classes</span></div>
<div class="line"> </div>
<div class="line">ir.def_constraint_class(<span class="stringliteral">&#39;Consecutive&#39;</span>,</div>
<div class="line">    <span class="keyword">lambda</span> i,var: var([(<span class="stringliteral">&#39;X&#39;</span>,i-1),(<span class="stringliteral">&#39;X&#39;</span>,i),(<span class="stringliteral">&#39;Y&#39;</span>,i-1),(<span class="stringliteral">&#39;ZC&#39;</span>,i)]),</div>
<div class="line">    <span class="keyword">lambda</span> xim1, xi, yim1, ci: (yim1 <span class="keywordflow">and</span> xim1+1==xi) == ci)</div>
<div class="line"> </div>
<div class="line">ir.def_constraint_class(<span class="stringliteral">&#39;BPMatch&#39;</span>,</div>
<div class="line">    <span class="keyword">lambda</span> i,j,k,b,var: var([(<span class="stringliteral">&#39;X&#39;</span>,i),(<span class="stringliteral">&#39;X&#39;</span>,j),(<span class="stringliteral">&#39;Y&#39;</span>,i),(<span class="stringliteral">&#39;Y&#39;</span>,j),(<span class="stringliteral">&#39;ZM&#39;</span>,k)]),</div>
<div class="line">    <span class="keyword">lambda</span> xi,xj,yi,yj,mk,b: (yi <span class="keywordflow">and</span> yj <span class="keywordflow">and</span> is_compl(b[xi-1],b[xj-1])) == mk)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># attention bps is 0-based, also note the assymetry for C</span></div>
<div class="line">ir.def_function_class(<span class="stringliteral">&#39;Stacking&#39;</span>,</div>
<div class="line">    <span class="keyword">lambda</span> k,l,bps,var: var([(<span class="stringliteral">&#39;ZM&#39;</span>,k),(<span class="stringliteral">&#39;ZM&#39;</span>,l),(<span class="stringliteral">&#39;ZC&#39;</span>,bps[k][0]+2),(<span class="stringliteral">&#39;ZC&#39;</span>,bps[k][1]+1)]),</div>
<div class="line">    <span class="keyword">lambda</span> mk, ml, cl, cr: 20 <span class="keywordflow">if</span> mk <span class="keywordflow">and</span> ml <span class="keywordflow">and</span> cl <span class="keywordflow">and</span> cr <span class="keywordflow">else</span> 0)</div>
</div><!-- fragment --><div class="fragment"><div class="line">model = alignment_model(ex[<span class="stringliteral">&#39;a&#39;</span>],ex[<span class="stringliteral">&#39;s&#39;</span>],ex[<span class="stringliteral">&#39;b&#39;</span>])</div>
<div class="line"> </div>
<div class="line">n=len(ex[<span class="stringliteral">&#39;a&#39;</span>])</div>
<div class="line">bps = rna.parse(ex[<span class="stringliteral">&#39;s&#39;</span>])</div>
<div class="line">var = model.idx</div>
<div class="line"> </div>
<div class="line">model.add_variables(2, (0,0), name=<span class="stringliteral">&#39;ZC&#39;</span>)</div>
<div class="line">model.add_variables(n-1, (0,1), name=<span class="stringliteral">&#39;ZC&#39;</span>)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment"># base pair matching; one variable per base pair indicating a match</span></div>
<div class="line">model.add_variables(len(bps), (0,1), name=<span class="stringliteral">&#39;ZM&#39;</span>)</div>
<div class="line"> </div>
<div class="line">model.add_constraints(Consecutive(i,var) <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(2,n))</div>
<div class="line">model.add_constraints(BPMatch(i+1,j+1,k,ex[<span class="stringliteral">&#39;b&#39;</span>],var) <span class="keywordflow">for</span> k,(i,j) <span class="keywordflow">in</span> enumerate(bps))</div>
<div class="line"> </div>
<div class="line">bps_index = {(x[0],x[1]):k <span class="keywordflow">for</span> k,x <span class="keywordflow">in</span> enumerate(bps)}</div>
<div class="line"> </div>
<div class="line">print(<span class="stringliteral">&#39;Stacking:&#39;</span>,ex[<span class="stringliteral">&#39;s&#39;</span>],bps)</div>
<div class="line">print([(k,bps_index[(x[0]+1,x[1]-1)]) <span class="keywordflow">for</span> k,x <span class="keywordflow">in</span> enumerate(bps) <span class="keywordflow">if</span> (x[0]+1,x[1]-1) <span class="keywordflow">in</span> bps_index])</div>
<div class="line"> </div>
<div class="line">model.add_functions([Stacking(k,bps_index[(x[0]+1,x[1]-1)],bps,var)</div>
<div class="line">                       <span class="keywordflow">for</span> k,x <span class="keywordflow">in</span> enumerate(bps) <span class="keywordflow">if</span> (x[0]+1,x[1]-1) <span class="keywordflow">in</span> bps_index],</div>
<div class="line">                    <span class="stringliteral">&#39;psi&#39;</span>)</div>
</div><!-- fragment --> <pre class="fragment">Stacking: (((.((.[[[[[.....)))))..]]]]] [(0, 21), (1, 20), (2, 19), (4, 18), (5, 17), (7, 28), (8, 27), (9, 26), (10, 25), (11, 24)]
[(0, 1), (1, 2), (3, 4), (5, 6), (6, 7), (7, 8), (8, 9)]
</pre><div class="fragment"><div class="line"> </div>
<div class="line">td_factory = NXOptDspTDFactory(model, verbose=<span class="keyword">True</span>)</div>
<div class="line">alioptimizer = ir.Optimizer( model, td_factory )</div>
<div class="line"> </div>
<div class="line">t0 = time.time()</div>
<div class="line"> </div>
<div class="line"><span class="comment">#print( &quot;Treewidth:&quot;, alioptimizer.treewidth())</span></div>
<div class="line">bags = alioptimizer.td.bags</div>
<div class="line">print( <span class="stringliteral">&quot;Effective Treewidth (on X_i):&quot;</span>, max(len( [ x <span class="keywordflow">for</span> x <span class="keywordflow">in</span> b <span class="keywordflow">if</span> x &lt;= n+1 ]) <span class="keywordflow">for</span> b <span class="keywordflow">in</span> bags) -1)</div>
<div class="line"> </div>
<div class="line">print(<span class="stringliteral">&quot;Banding:&quot;</span>, c)</div>
<div class="line"> </div>
<div class="line">alioptimizer.plot_td(<span class="stringliteral">&quot;treedecomp.pdf&quot;</span>)</div>
<div class="line">      </div>
<div class="line">print(f<span class="stringliteral">&quot;t = {time.time()-t0:.1f}s&quot;</span>)</div>
<div class="line"> </div>
<div class="line">best_score = round( alioptimizer.evaluate() )</div>
<div class="line">print(f<span class="stringliteral">&quot;Optimal alignment score: {best_score}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">best_alignment = alioptimizer.optimize()</div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>report_assignment(alignment):   </div>
<div class="line">    <span class="comment"># the following translation of indices to names should become part of the library</span></div>
<div class="line">    index_to_namedvar=[]</div>
<div class="line">    varnames = list(model._domains.keys())</div>
<div class="line">    <span class="keywordflow">for</span> name <span class="keywordflow">in</span> varnames:</div>
<div class="line">        num = model.num_named_variables(name)</div>
<div class="line">        <span class="keywordflow">for</span> idx <span class="keywordflow">in</span> range(num):</div>
<div class="line">            index_to_namedvar.append( f<span class="stringliteral">&quot;{name}{idx}&quot;</span> )</div>
<div class="line">    </div>
<div class="line">    print(<span class="stringliteral">&#39;Assignment: &#39;</span>, {index_to_namedvar[i]:v <span class="keywordflow">for</span> i,v <span class="keywordflow">in</span> enumerate(alignment.values())})</div>
<div class="line">    </div>
<div class="line">report_alignment(best_alignment)</div>
<div class="line">report_assignment(best_alignment)</div>
<div class="line">print(f<span class="stringliteral">&quot;t = {time.time()-t0:.1f}s&quot;</span>)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">print(<span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;----- TD Info -----&quot;</span>)</div>
<div class="line">show_td_info(alioptimizer,width=900)</div>
</div><!-- fragment --> <pre class="fragment">After iteration 34 : Treewidth: 9, Domain size product sum: 1.81e+07
Effective Treewidth (on X_i): 4
Banding: 4
t = 0.5s
Optimal alignment score: 120
Score 120 = 50 + -20 + 90
(((.((.[[[[[...-..-)))))..]]]-]]
GGCGCCAAUAUCCAA-UA-GGGUCCUGGU-AU
GGC-CC-AUAUUCAAAUAAGGGACCUGGUCAU
(.(-((-[[[[[.......))).)..]]].]]

Assignment:  {'X0': 0, 'X1': 1, 'X2': 2, 'X3': 3, 'X4': 3, 'X5': 4, 'X6': 5, 'X7': 5, 'X8': 6, 'X9': 7, 'X10': 8, 'X11': 9, 'X12': 10, 'X13': 11, 'X14': 12, 'X15': 13, 'X16': 15, 'X17': 16, 'X18': 18, 'X19': 19, 'X20': 20, 'X21': 21, 'X22': 22, 'X23': 23, 'X24': 24, 'X25': 25, 'X26': 26, 'X27': 27, 'X28': 29, 'X29': 30, 'X30': 31, 'Y0': 1, 'Y1': 1, 'Y2': 1, 'Y3': 1, 'Y4': 0, 'Y5': 1, 'Y6': 1, 'Y7': 0, 'Y8': 1, 'Y9': 1, 'Y10': 1, 'Y11': 1, 'Y12': 1, 'Y13': 1, 'Y14': 1, 'Y15': 1, 'Y16': 1, 'Y17': 1, 'Y18': 1, 'Y19': 1, 'Y20': 1, 'Y21': 1, 'Y22': 1, 'Y23': 1, 'Y24': 1, 'Y25': 1, 'Y26': 1, 'Y27': 1, 'Y28': 1, 'Y29': 1, 'ZC0': 0, 'ZC1': 0, 'ZC2': 1, 'ZC3': 1, 'ZC4': 0, 'ZC5': 0, 'ZC6': 1, 'ZC7': 0, 'ZC8': 0, 'ZC9': 1, 'ZC10': 1, 'ZC11': 1, 'ZC12': 1, 'ZC13': 1, 'ZC14': 1, 'ZC15': 1, 'ZC16': 0, 'ZC17': 1, 'ZC18': 0, 'ZC19': 1, 'ZC20': 1, 'ZC21': 1, 'ZC22': 1, 'ZC23': 1, 'ZC24': 1, 'ZC25': 1, 'ZC26': 1, 'ZC27': 1, 'ZC28': 0, 'ZC29': 0, 'ZM0': 1, 'ZM1': 0, 'ZM2': 1, 'ZM3': 1, 'ZM4': 1, 'ZM5': 1, 'ZM6': 1, 'ZM7': 1, 'ZM8': 1, 'ZM9': 1}
t = 4.5s


----- TD Info -----
tree width = 9
</pre><p ><img src="Alignment_files/Alignment_29_1.png" alt="png" class="inline"/> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
